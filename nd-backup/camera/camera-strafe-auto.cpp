/*
* Copyright (c) 2019 Naughty Dog, Inc.
* A Wholly Owned Subsidiary of Sony Computer Entertainment, Inc.
* Use and distribution without consent strictly prohibited
*/

#include "gamelib/camera/camera-strafe-auto.h"
#include "gamelib/camera/camera-manager.h"

#include "corelib/math/intersection.h"
#include "ndlib/camera/camera-option.h"

FROM_PROCESS_DEFINE(CameraControlStrafeAutoGenerated);

//----------------------------------------------------------------------------------------------//
void CameraControlStrafeAutoGenerated::Initialize(const CameraStartInfo& baseStartInfo)
{
	const CameraStrafeAutoGenStartInfo& startInfo = *PunPtr<const CameraStrafeAutoGenStartInfo*>(&baseStartInfo);
	GAMEPLAY_ASSERT(startInfo.m_signature == SID("CameraStrafeAutoGenStartInfo"));

	ParentClass::Initialize(baseStartInfo);

	m_params = startInfo.m_params;

	KillWhenBlendedOut();
}

//----------------------------------------------------------------------------------------------//
void CameraControlStrafeAutoGenerated::CalcInitArcAndYaw(const CameraStartInfo& baseStartInfo)
{
	const CameraStrafeAutoGenStartInfo& startInfo = *PunPtr<const CameraStrafeAutoGenStartInfo*>(&baseStartInfo);
	GAMEPLAY_ASSERT(startInfo.m_signature == SID("CameraStrafeAutoGenStartInfo"));

	const Locator desiredCharLoc = m_params.m_characterLoc;
	const Point desiredCharPos = desiredCharLoc.GetTranslation();
	const Quat desiredCharRot = desiredCharLoc.GetRotation();
	const Locator desiredCamLoc = m_params.m_cameraLoc;
	const Point desiredCamPos = desiredCamLoc.GetTranslation();
	const Quat desiredCamRot = desiredCamLoc.GetRotation();
	const Vector desiredCamDir = GetLocalZ(desiredCamRot);

	// Set m_targetOffset:
	//		such that base-target is at the same xz-position as the player!
	{
		m_targetOffset = Vector(0.0f, 1.0f, 0.0f);	// Should only contains a Y-offset!
	}

	// Set m_arc & m_yawControl:
	//		such that the camera direction matches the IGC
	SetLookAtDir(GetLocalZ(desiredCamRot));
	const Vector yawCtrlCameraDirXZ = m_yawControl.GetCurrentDirWs();		// This is NOT the camera forward direction!
	
	// Calculate the arc modifiers:
	float newSideOffset;
	Vec2 newArcOffsetDelta;
	CalculateMatchingSettings(desiredCharLoc, desiredCamLoc, yawCtrlCameraDirXZ, m_targetOffset, &newSideOffset, &newArcOffsetDelta);

	// Update the arc settings:
	//		such that the camera position matches the IGC
	{
		m_currentSideOffset = newSideOffset / g_cameraOffsetScale;
		GAMEPLAY_ASSERT(IsFinite(m_currentSideOffset));
		m_verticalArc.UpdateCameraPointArc(newArcOffsetDelta);
		m_verticalArc.UpdateTargetPointArc(newArcOffsetDelta);
	}
	
	// Validation Checks
	{
		// Calc final positions
		Point adjustedTargetPosWs;
		Point adjustedCameraPosWs;
		Point adjustedBaseTargetPosWs;
		{
			adjustedBaseTargetPosWs = GetTargetPositionFromBaseLoc(desiredCharLoc, m_targetOffset);
			const Point	targetPosWoSideOffsetWs = m_verticalArc.OffsetTargetPoint(adjustedBaseTargetPosWs, yawCtrlCameraDirXZ, m_arc, kUnitYAxis);
			const Point cameraPosWoSideOffsetWs = CalcCameraPosition(adjustedBaseTargetPosWs, yawCtrlCameraDirXZ, m_arc);

			// calculate side-offset
			Vector sideOffset;
			{
				const Vector cameraToTargetRaw = targetPosWoSideOffsetWs - cameraPosWoSideOffsetWs;
				const Vector cameraLeft = SafeNormalize(Cross(kUnitYAxis, cameraToTargetRaw), kZero);
				sideOffset = m_currentSideOffset * cameraLeft * g_cameraOffsetScale;
			}

			adjustedTargetPosWs = targetPosWoSideOffsetWs + sideOffset;
			adjustedCameraPosWs = cameraPosWoSideOffsetWs + sideOffset;
		}

		// Calc final direction
		const Vector adjustedCamDir = SafeNormalize(adjustedTargetPosWs - adjustedCameraPosWs, kUnitZAxis);

		// Validate Direction
		const float dotProduct = Dot(desiredCamDir, adjustedCamDir);
		GAMEPLAY_ASSERT(IsClose(dotProduct, 1.0f, 0.0001f));

		// Validate Position
		const float errorDistance = Length(adjustedCameraPosWs - desiredCamPos);
		GAMEPLAY_ASSERT(IsClose(errorDistance, 0.0f, 0.001f));

		// Debug
		if(FALSE_IN_FINAL_BUILD(g_cameraOptions.m_debugAnimatedOutro))
		{
			g_prim.Draw(DebugCross(adjustedTargetPosWs, 0.1f, kColorOrange), Seconds(3.f));
			g_prim.Draw(DebugString(adjustedTargetPosWs, "new-prep-cam-tgt", kColorWhite, 0.6f), Seconds(3.f));

			g_prim.Draw(DebugCross(adjustedCameraPosWs, 0.1f, kColorBlue), Seconds(3.f));
			g_prim.Draw(DebugString(adjustedCameraPosWs, "\nnew-prep-cam-pos", kColorBlue, 0.6f), Seconds(3.f));

			g_prim.Draw(DebugCross(adjustedBaseTargetPosWs, 0.1f, kColorPink), Seconds(3.f));
			g_prim.Draw(DebugString(adjustedBaseTargetPosWs, "desired-base-tgt", kColorWhite, 0.6f), Seconds(3.f));
		}
	}

	// calculate arc-range limit.
	{
		const int numSegments = 15;
		const float thresholdY = Sin(DEGREES_TO_RADIANS(75.f));
		const float centerArc = 0.5f;

		Vec2 newRange = Vec2(0, 1);
		for (int kk = 1; kk < numSegments + 1; kk++)
		{
			float testArc = MinMax01(centerArc - 0.5f * kk / (float)numSegments);
			const Vector testCamDir = CalcCameraDir(yawCtrlCameraDirXZ, testArc);
			if (Abs(testCamDir.Y()) >= thresholdY)
			{
				newRange.x = testArc;
				break;
			}
		}

		for (int kk = 1; kk < numSegments + 1; kk++)
		{
			float testArc = MinMax01(centerArc + 0.5f * kk / (float)numSegments);
			const Vector testCamDir = CalcCameraDir(yawCtrlCameraDirXZ, testArc);
			if (Abs(testCamDir.Y()) >= thresholdY)
			{
				newRange.y = testArc;
				break;
			}
		}

		m_arcRange = newRange;
	}

	const CameraControl* pPrevCamera = CameraManager::GetGlobal(GetPlayerIndex()).GetCurrentCamera();
	if (LengthSqr(m_params.m_initDirection) > 0.f)
	{
		SetLookAtDir(m_params.m_initDirection);
	}
	else
	{
		// finally set yaw-control using previous camera.
		const Locator prevCamLoc = pPrevCamera->GetLocator();
		SetLookAtDir(GetLocalZ(prevCamLoc.GetRotation()));
	}

	// Initialize for target dir resets the spring, so set it again here
	const CameraControlStrafeBase* pPrevStrafeCamera = CameraControlStrafeBase::FromProcess(pPrevCamera);
	if (pPrevStrafeCamera != nullptr)
	{
		if (const DC::CameraStrafeBaseSettings* pPrevStrafeCamSettings = ScriptManager::Lookup<DC::CameraStrafeBaseSettings>(pPrevStrafeCamera->GetDCSettingsId(), nullptr))
		{
			const float startSpeed = pPrevStrafeCamera->GetYawController().GetCurrentHorizontalSpeed();
			m_yawControl.SetInitialSpeed(startSpeed, pPrevStrafeCamSettings->m_yawSpringSettings.m_activeSettings.m_springConst);
			m_yawControl.SetRequestedAnglePs(pPrevStrafeCamera->GetYawController().GetRequestedAnglePs());
		}
	}
}

//----------------------------------------------------------------------------------------------//
CameraBlendInfo CameraControlStrafeAutoGenerated::CalcBlendInfo(const CameraStartInfo& baseStartInfo) const
{
	const CameraStrafeAutoGenStartInfo& startInfo = *PunPtr<const CameraStrafeAutoGenStartInfo*>(&baseStartInfo);
	GAMEPLAY_ASSERT(startInfo.m_signature == SID("CameraStrafeAutoGenStartInfo"));

	const CameraRemapParamsEx& remapParams = GetRemapParams();
	if (remapParams.m_distParams.Valid())
	{
		DistCameraParams inParams = remapParams.m_distParams;
		inParams.m_immediate = startInfo.m_immediate;

		CameraBlendInfo retVal(inParams);
		retVal.m_instantBlend = remapParams.m_instantBlend;
		return retVal;
	}

	return CameraBlendInfo(Seconds(0.f));
}

//----------------------------------------------------------------------------------------------//
CameraRemapSettings CameraControlStrafeAutoGenerated::RemapSettingsId(StringId64 baseDcSettingsId, bool includeDistRemap) const
{
	if (m_params.m_cameraOverlayId != INVALID_STRING_ID_64)
	{
		const CameraRemapSettings remapSettings = RemapCameraSettingsId(baseDcSettingsId, m_params.m_cameraOverlayId);
		return remapSettings;
	}
	else
	{
		return ParentClass::RemapSettingsId(baseDcSettingsId, includeDistRemap);
	}
}

//----------------------------------------------------------------------------------------------//
// give desired character locator and desired camera locator, calculate the settings to match it.
// it doesn't change the current yaw or arc (pitch)
//----------------------------------------------------------------------------------------------//
void CameraControlStrafeAutoGenerated::CalculateMatchingSettings(const Locator& desiredCharLoc, 
																 const Locator& desiredCamLoc,
																 const Vector& yawCtrlCameraDirXZ,
																 const Vector& baseTargetOffsetFromChar,
																 float* pOutSideOffset,
																 Vec2* pOutNewArcOffsetDelta) const
{
	const Point desiredCharPos = desiredCharLoc.GetTranslation();
	const Point desiredCamPos = desiredCamLoc.GetTranslation();

	// Calculate the side offset
	// -> pOutSideOffset
	{
		Point camPosWoSideOffset;
		Point targetPosWoSideOffset;
		Point baseTargetPosWs;
		{
			baseTargetPosWs = GetTargetPositionFromBaseLoc(desiredCharLoc, m_targetOffset);
			targetPosWoSideOffset = m_verticalArc.OffsetTargetPoint(baseTargetPosWs, yawCtrlCameraDirXZ, m_arc, kUnitYAxis);
			camPosWoSideOffset = CalcCameraPosition(baseTargetPosWs, yawCtrlCameraDirXZ, m_arc);
		}

		const Vector camToTargetRaw = targetPosWoSideOffset - camPosWoSideOffset;
		const Vector cameraLeftDir = SafeNormalize(Cross(kUnitYAxis, camToTargetRaw), kZero);
		const Vector baseTargetToDesiredCameraWs = desiredCamPos - baseTargetPosWs;
		const float sideOffset = Dot(cameraLeftDir, baseTargetToDesiredCameraWs);
		*pOutSideOffset = sideOffset;
	}

	// Calculate the arc offset
	// -> pOutNewArcOffsetDelta
	{
		Point adjustedTargetPosWs;
		Point adjustedCameraPosWs;
		{
			const Point adjustedBaseTargetPosWs = GetTargetPositionFromBaseLoc(desiredCharLoc, m_targetOffset);
			const Point targetPosWoSideOffsetWs = m_verticalArc.OffsetTargetPoint(adjustedBaseTargetPosWs, yawCtrlCameraDirXZ, m_arc, kUnitYAxis);
			const Point cameraPosWoSideOffsetWs = CalcCameraPosition(adjustedBaseTargetPosWs, yawCtrlCameraDirXZ, m_arc);

			// get the side-offset to apply
			Vector sideOffset;
			{
				const Vector cameraToTargetRaw = targetPosWoSideOffsetWs - cameraPosWoSideOffsetWs;
				const Vector cameraLeft = SafeNormalize(Cross(kUnitYAxis, cameraToTargetRaw), kZero);
				sideOffset = (*pOutSideOffset) * cameraLeft * g_cameraOffsetScale;
			}

			// final positions
			adjustedTargetPosWs = targetPosWoSideOffsetWs + sideOffset;
			adjustedCameraPosWs = cameraPosWoSideOffsetWs + sideOffset;
		}
		
		const Vector camPosDifference = desiredCamPos - adjustedCameraPosWs;
		const float xzDifference = Dot(yawCtrlCameraDirXZ, camPosDifference);
		const float yDifference = Dot(kUnitYAxis, camPosDifference);
		pOutNewArcOffsetDelta->SetX(xzDifference);
		pOutNewArcOffsetDelta->SetY(yDifference);
	}
}

//----------------------------------------------------------------------------------------------//
Point CameraControlStrafeAutoGenerated::GetTargetPositionFromBaseLoc(const Locator& baseLoc, Vector_arg targetOffset)
{
	Vector offsetWs = kZero;

	if (LengthSqr(targetOffset) > 0.f)
	{
		offsetWs = Rotate(baseLoc.GetRotation(), targetOffset);
	}

	const Point baseTargetPosWs = baseLoc.GetTranslation() + offsetWs;
	return baseTargetPosWs;
}

//----------------------------------------------------------------------------------------------//
Point CameraControlStrafeAutoGenerated::GetBaseLookAtPointWs() const
{
	const NdGameObject* pFocusGo = m_hFocusObj.ToProcess();
	return pFocusGo != nullptr ? pFocusGo->GetTranslation() : Point(kOrigin);
}

///-------------------------------------------------------------------------------------------///
Point CameraControlStrafeAutoGenerated::GetTargetPosition(const NdGameObject* pFocusGo) const
{
	const Point basePoint = GetBaseLookAtPointWs();
	Vector offsetWs = kZero;

	if (pFocusGo && LengthSqr(m_targetOffset) > 0.f)
	{
		offsetWs = Rotate(pFocusGo->GetRotation(), m_targetOffset);
	}

	const Point baseTargetPosWs = basePoint + offsetWs;

	if (FALSE_IN_FINAL_BUILD(g_strafeCamDbgOptions.m_displayTarget))
	{
		g_prim.Draw(DebugCross(basePoint, 0.25f, Color(0.0f, 0.2f, 0.0f), PrimAttrib(kPrimEnableHiddenLineAlpha), "auto-base", 0.5f), kPrimDuration1FramePauseable);
		g_prim.Draw(DebugCross(baseTargetPosWs, 0.2f, kColorGreen, PrimAttrib(kPrimEnableHiddenLineAlpha), "auto-base-target", 0.5f), kPrimDuration1FramePauseable);
	}

	return baseTargetPosWs;
}

//----------------------------------------------------------------------------------------------//
void CameraControlStrafeAutoGenerated::PrepareFinalize(bool isTopControl, const CameraControl* pPrevControl)
{
	ParentClass::PrepareFinalize(isTopControl, pPrevControl);

	if (FALSE_IN_FINAL_BUILD(g_cameraOptions.m_debugAnimatedOutro))
	{
		g_prim.Draw(DebugCoordAxes(m_params.m_characterLoc, 0.3f, PrimAttrib(kPrimEnableHiddenLineAlpha)), kPrimDuration1FramePauseable);
		g_prim.Draw(DebugString(m_params.m_characterLoc.GetTranslation(), "desired-align", kColorWhite, 0.6f), kPrimDuration1FramePauseable);
		g_prim.Draw(DebugArrow(m_params.m_characterLoc.GetTranslation(), GetLocalZ(m_params.m_characterLoc.GetRotation()) * 0.3f, kColorBlue, 0.4f, PrimAttrib(kPrimEnableHiddenLineAlpha)), kPrimDuration1FramePauseable);

		g_prim.Draw(DebugCoordAxes(m_params.m_cameraLoc, 0.3f, PrimAttrib(kPrimEnableHiddenLineAlpha)), kPrimDuration1FramePauseable);
		g_prim.Draw(DebugString(m_params.m_cameraLoc.GetTranslation(), "desired-camera", kColorWhite, 0.6f), kPrimDuration1FramePauseable);

		if (m_params.m_igcName != INVALID_STRING_ID_64)
		{
			g_prim.Draw(DebugCoordAxes(m_params.m_igcApLoc, 0.3f, PrimAttrib(kPrimEnableHiddenLineAlpha)), kPrimDuration1FramePauseable);
			g_prim.Draw(DebugString(m_params.m_igcApLoc.GetTranslation(), DevKitOnly_StringIdToString(m_params.m_igcName), kColorWhite, 0.6f), kPrimDuration1FramePauseable);
			g_prim.Draw(DebugArrow(m_params.m_igcApLoc.GetTranslation(), GetLocalZ(m_params.m_igcApLoc.GetRotation()) * 0.3f, kColorOrange, 0.4f, PrimAttrib(kPrimEnableHiddenLineAlpha)), kPrimDuration1FramePauseable);
		}
	}
}

//----------------------------------------------------------------------------------------------//
float CameraControlStrafeAutoGenerated::GetFov() const
{
	if (m_params.m_animatedFov > 0.f)
		return m_params.m_animatedFov;
	else
		return ParentClass::GetFov();
}

PROCESS_REGISTER(CameraControlStrafeAutoGenerated, CameraControlStrafeBase);
CAMERA_REGISTER(kCameraStrafeAutoGen, CameraControlStrafeAutoGenerated, CameraStrafeStartInfo, CameraPriority::Class::kGameplay);

