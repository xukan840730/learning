#ifndef RAY_INTERSECT_FXI
#define RAY_INTERSECT_FXI

static const float kMaxT = 1e30f;

struct Ray
{
	float3	pos;
	float3	dir;
	float3	attenuation;
	bool	shadowRay;
	bool	killed;
};

float2	RayVsSphere(Ray r, float4 s)
{
	// Find closest intersection point using quadradic solve
	float3 v = r.pos - s.xyz;
	float b = dot(v, r.dir);
	float c = dot(v, v) - s.w*s.w;

	float disc = b*b - c;
	if (disc < 0.f)
		return kMaxT;

	disc = sqrt(disc);
	float t1 = -b - disc;
	float t2 = -b + disc;

	return float2(t1, t2);
}

// moller trumbore intersection method
// http://www.cs.virginia.edu/~gfx/Courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf

float3 RayVsTriangle(Ray r, uint3 tri, DataBuffer<float4>	verts)
{
	float	epsilon = 1e-6f;

	float3	v0 = verts[tri[0]].xyz;
	float3	v1 = verts[tri[1]].xyz;
	float3	v2 = verts[tri[2]].xyz;

	float3	e1 = v1 - v0;
	float3	e2 = v2 - v0;
	float3	t = r.pos - v0;
	float3	d = r.dir;

	float3	p = cross(d, e2);
	float3	q = cross(t, e1);

	float	det = dot(p, e1);
	if (abs(det) < epsilon)
		return float3(kMaxT, 0.f, 0.f);

	float3	ret = float3(dot(q, e2), dot(p, t), dot(q, d)) / det;
	if (ret.x < 0.f || ret.y < 0.f || ret.z < 0.f || ret.y + ret.z > 1.f)
		return float3(kMaxT, 0.f, 0.f);
	else
		return ret;
}

float3 RayVsUnitQuad(Ray r)
{
	// solve for the intersection of the ray with a "normalized" plane
	// (at origin, oriented along y)

	float	t = -r.pos.z / r.dir.z;

	// calculate intersection point on plane
	float3	p = r.pos + r.dir*t;

	if (p.x >= -1.f && p.x <= 1.f && p.y >= -1.f && p.y <= 1.f)
	{
		// we only need t here, tho i should make this consistent with RayVsTri in future.
		return float3(t, 0.f, 0.f);
	}
	else
	{
		return float3(kMaxT, 0.f, 0.f);
	}
}

float2	RayVsAabb(Ray r, float3 minpos, float3 maxpos)
{
	// ray/box intersection
	float3 t1 = (minpos - r.pos) / r.dir;
	float3 t2 = (maxpos - r.pos) / r.dir;

	float3	tmin = min(t1, t2);
	float3	tmax = max(t1, t2);

	float	maxmin = max(max(tmin.x, tmin.y), tmin.z);
	float	minmax = min(min(tmax.x, tmax.y), tmax.z);

	if (maxmin > minmax)
		return float2(kMaxT, kMaxT);
	else
		return float2(maxmin, minmax);
}

#endif