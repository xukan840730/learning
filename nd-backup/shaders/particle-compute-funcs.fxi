#ifndef PARTICLE_COMPUTE_FUNCS
#define PARTICLE_COMPUTE_FUNCS

#define kMaxErrorFrames 10


float3 CalculatePreviousFramePosition(ParticleComputeJobSrt *pSrt, float3 posNDC, uint2 posSS )
{
	// calculate velocity from motion vector
	float2 motionVectorSNorm = pSrt->m_pPassDataSrt->m_motionVector[posSS];
	int2 motionVector   = int2(motionVectorSNorm * pSrt->m_screenResolution);
	int2 lastFrameSSpos = int2(float2(posSS)+motionVector);

	float3 posNdcUnjittered = posNDC;
	posNdcUnjittered.xy -= pSrt->m_projectionJitterOffsets.xy;

	// trace backwards along motion vector to get previous position
	float3 lastFramePosNdcUnjittered = float3(posNdcUnjittered.x + motionVectorSNorm.x * 2, 
												posNdcUnjittered.y - motionVectorSNorm.y * 2, 
												pSrt->m_pPassDataSrt->m_lastFrameOpaquePlusAlphaDepthTexture[lastFrameSSpos]);
	float3 lastFramePosNdc = lastFramePosNdcUnjittered;
	lastFramePosNdc.xy += pSrt->m_projectionJitterOffsets.zw;

	float4 lastFramePosH = mul(float4(lastFramePosNdc, 1), pSrt->m_pPassDataSrt->m_mLastFrameAltVPInv);
	float3 lastFramePosWs = lastFramePosH.xyz / lastFramePosH.w;
	lastFramePosWs += pSrt->m_lastFrameAltWorldOrigin;

	return lastFramePosWs;
}

void UpdateTrackingParticle(ParticleComputeJobSrt *pSrt, 
	inout float3 position, inout float3 velocity, inout uint particleErrorState, 
	inout uint prevStencil)
{
	float3 prevPos = position;

	// integrate position with tracking delta
	position = position + velocity * pSrt->m_delta;

	if (particleErrorState != 0)
	{
		// try using new position only after a couple of failures
		if (particleErrorState > 2)
			position = prevPos;
	}

	DepthPosInfo newPos = DPISetup(position, pSrt);

	if (abs(newPos.posNDC.x) > 1 || abs(newPos.posNDC.y) > 1)
	{
		// outside of screen
		particleErrorState = kMaxErrorFrames;
	}

	uint origErrorState = particleErrorState;
	if (particleErrorState < kMaxErrorFrames)
	{
		// clear error for this update
		particleErrorState = 0;
	}
	
	// validate the tracking delta
	if (particleErrorState == 0)
	{	
		DPISampleDepth(newPos, pSrt, false);

		if (abs(newPos.depthDiff) > 0.1 || 
				prevStencil != pSrt->m_pPassDataSrt->m_opaquePlusAlphaStencil[newPos.posSS])
		{	
			// depth difference to big or stencil changed
			// incorrect tracking delta, move back
			position = prevPos;
			particleErrorState = 1;
		}

	}

	// recover from invalid tracking delta
	if (particleErrorState != 0)
	{
		newPos = DPISetup(position, pSrt);

		DPISampleDepth(newPos, pSrt, false);

		if (abs(newPos.depthDiff) > 0.1 ||
			prevStencil != pSrt->m_pPassDataSrt->m_opaquePlusAlphaStencil[newPos.posSS])
		{
			// previous position was invalid too
		}
		else
		{
			particleErrorState = 0;
		}
	}

	// tracking delta valid, adjust position
	if (particleErrorState == 0)
	{
		DPIGetDepthPos(newPos, pSrt);
		position = newPos.depthPosWS;

		float3 lastFramePosWs = CalculatePreviousFramePosition(pSrt, newPos.posNDC, newPos.posSS);

		// compare previous position of current pixel with projected previous position to handle acceleration
		if (origErrorState)
		{
			prevPos = lastFramePosWs;
		}

		float3 lastFramePosUnexpectedOffset = prevPos - lastFramePosWs;

		prevPos = position;

		position += lastFramePosUnexpectedOffset;

		// reproject using adjusted position
		newPos = DPISetup(position, pSrt);
		DPISampleDepth(newPos, pSrt, false);

		if (abs(newPos.depthDiff) > 0.1 ||
			prevStencil != pSrt->m_pPassDataSrt->m_opaquePlusAlphaStencil[newPos.posSS])
		{
			// adjusted position is invalid, use old position
			position = prevPos;
			velocity = (position - lastFramePosWs) / pSrt->m_delta;
		}
		else
		{

			// final position adjustment
			DPIGetDepthPos(newPos, pSrt);
			position = newPos.depthPosWS;

			// update the stored stencil
			prevStencil = pSrt->m_pPassDataSrt->m_opaquePlusAlphaStencil[newPos.posSS];
			
			// calculate tracking velocity
			lastFramePosWs = CalculatePreviousFramePosition(pSrt, newPos.posNDC, newPos.posSS);
			velocity = (position - lastFramePosWs) / pSrt->m_delta;

		}
	}
	// if != we either are on first frame of error or we continuing error state
	if (particleErrorState != 0) 
	{
		particleErrorState += origErrorState; // accumulate error frames
	}	
}

#endif
