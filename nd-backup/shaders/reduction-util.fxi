/*
 * Copyright (c) 2015 Naughty Dog, Inc.
 * A Wholly Owned Subsidiary of Sony Computer Entertainment, Inc.
 * Use and distribution without consent strictly prohibited.
 */

#ifndef __REDUCTION_UTIL_H__
#define __REDUCTION_UTIL_H__

#ifndef REDUCTION_TILE_SIZE
#error You need to define REDUCTION_TILE_SIZE before including this file due to the need to declare some LDS
#endif

#if REDUCTION_TILE_SIZE > 8
groupshared float2 s_minMaxValues[(REDUCTION_TILE_SIZE*REDUCTION_TILE_SIZE)/64];
groupshared float s_minValues[(REDUCTION_TILE_SIZE*REDUCTION_TILE_SIZE)/64];
#endif

void MinMaxReduceMinMax(uint threadGroupIndex, inout float minValue, inout float maxValue)
{
	// Do a simple reduction using lane swizzling
	
	// Step 1: Get 16 (flip the 5th bit)
	float reduceMin = LaneSwizzle(minValue, 0x1F, 0x00, 0x10);
	float reduceMax = LaneSwizzle(maxValue, 0x1F, 0x00, 0x10);
	minValue = min(minValue, reduceMin);
	maxValue = max(maxValue, reduceMax);

	// Step 2: Get the min/max depth of the 8th lane
	reduceMin = LaneSwizzle(minValue, 0x1F, 0x00, 0x8);
	reduceMax = LaneSwizzle(maxValue, 0x1F, 0x00, 0x8);
	minValue = min(minValue, reduceMin);
	maxValue = max(maxValue, reduceMax);

	// Step 3: Get the min/max of the 4th lane
	reduceMin = LaneSwizzle(minValue, 0x1F, 0x00, 0x4);
	reduceMax = LaneSwizzle(maxValue, 0x1F, 0x00, 0x4);
	minValue = min(minValue, reduceMin);
	maxValue = max(maxValue, reduceMax);

	// Step 4: Get the min/max of the 2nd lane
	reduceMin = LaneSwizzle(minValue, 0x1F, 0x00, 0x2);
	reduceMax = LaneSwizzle(maxValue, 0x1F, 0x00, 0x2);
	minValue = min(minValue, reduceMin);
	maxValue = max(maxValue, reduceMax);

	// Step 5: Get the min/max of the 1st lane
	reduceMin = LaneSwizzle(minValue, 0x1F, 0x00, 0x1);
	reduceMax = LaneSwizzle(maxValue, 0x1F, 0x00, 0x1);
	minValue = min(minValue, reduceMin);
	maxValue = max(maxValue, reduceMax);

	// Finally, get the minmax of the other group of 32 registers
	minValue = min(ReadLane(minValue, 0), ReadLane(minValue, 32));
	maxValue = max(ReadLane(maxValue, 0), ReadLane(maxValue, 32));

	#if REDUCTION_TILE_SIZE >= 16
	uint waveFront = threadGroupIndex / 64;
	s_minMaxValues[waveFront] = float2(minValue, maxValue);
	ThreadGroupMemoryBarrierSync();

	const uint NUM_WAVEFRONTS = (REDUCTION_TILE_SIZE*REDUCTION_TILE_SIZE)/64;

	for (uint s = NUM_WAVEFRONTS/2; s > 0; s /= 2)
	{
		if (waveFront < s)
		{
			float2 neighbor = s_minMaxValues[waveFront + s];
			float2 current = s_minMaxValues[waveFront];
			s_minMaxValues[waveFront] = float2(min(current.x, neighbor.x),
				max(current.y, neighbor.y));
		}
		ThreadGroupMemoryBarrierSync();
	}

	float2 current = s_minMaxValues[0];
	minValue = current.x;
	maxValue = current.y;	
	#endif
}

float2 MinMaxReduce(uint threadGroupIndex, float value)
{
	// Do a simple reduction using lane swizzling
	float minValue = value, maxValue = value;
	
	// Step 1: Get 16 (flip the 5th bit)
	float reduceMin = LaneSwizzle(value, 0x1F, 0x00, 0x10);
	minValue = min(minValue, reduceMin);
	maxValue = max(maxValue, reduceMin);

	// Step 2: Get the min/max of the 8th lane
	reduceMin = LaneSwizzle(minValue, 0x1F, 0x00, 0x8);
	float reduceMax = LaneSwizzle(maxValue, 0x1F, 0x00, 0x8);
	minValue = min(minValue, reduceMin);
	maxValue = max(maxValue, reduceMax);

	// Step 3: Get the min/max of the 4th lane
	reduceMin = LaneSwizzle(minValue, 0x1F, 0x00, 0x4);
	reduceMax = LaneSwizzle(maxValue, 0x1F, 0x00, 0x4);
	minValue = min(minValue, reduceMin);
	maxValue = max(maxValue, reduceMax);

	// Step 4: Get the min/max of the 2nd lane
	reduceMin = LaneSwizzle(minValue, 0x1F, 0x00, 0x2);
	reduceMax = LaneSwizzle(maxValue, 0x1F, 0x00, 0x2);
	minValue = min(minValue, reduceMin);
	maxValue = max(maxValue, reduceMax);

	// Step 5: Get the min/max of the 1st lane
	reduceMin = LaneSwizzle(minValue, 0x1F, 0x00, 0x1);
	reduceMax = LaneSwizzle(maxValue, 0x1F, 0x00, 0x1);
	minValue = min(minValue, reduceMin);
	maxValue = max(maxValue, reduceMax);

	// Finally, get the minmax of the other group of 32 registers
	minValue = min(ReadLane(minValue, 0), ReadLane(minValue, 32));
	maxValue = max(ReadLane(maxValue, 0), ReadLane(maxValue, 32));

	#if REDUCTION_TILE_SIZE >= 16
	uint waveFront = threadGroupIndex / 64;
	s_minMaxValues[waveFront] = float2(minValue, maxValue);
	ThreadGroupMemoryBarrierSync();

	const uint NUM_WAVEFRONTS = (REDUCTION_TILE_SIZE*REDUCTION_TILE_SIZE)/64;

	for (uint s = NUM_WAVEFRONTS/2; s > 0; s /= 2)
	{
		if (waveFront < s)
		{
			float2 neighbor = s_minMaxValues[waveFront + s];
			float2 current = s_minMaxValues[waveFront];
			s_minMaxValues[waveFront] = float2(min(current.x, neighbor.x),
				max(current.y, neighbor.y));
		}
		ThreadGroupMemoryBarrierSync();
	}

	float2 current = s_minMaxValues[0];
	minValue = current.x;
	maxValue = current.y;	
	#endif

	return float2(minValue, maxValue);
}

float MinReduce(uint threadGroupIndex, float value)
{
	// Do a simple reduction using lane swizzling
	float minValue = value;
	
	// Step 1: Get 16 (flip the 5th bit)
	float reduce = LaneSwizzle(minValue, 0x1F, 0x00, 0x10);
	minValue = min(minValue, reduce);

	// Step 2: Get the min/max of the 8th lane
	reduce = LaneSwizzle(minValue, 0x1F, 0x00, 0x8);
	minValue = min(minValue, reduce);

	// Step 3: Get the min/max of the 4th lane
	reduce = LaneSwizzle(minValue, 0x1F, 0x00, 0x4);
	minValue = min(minValue, reduce);

	// Step 4: Get the min/max of the 2nd lane
	reduce = LaneSwizzle(minValue, 0x1F, 0x00, 0x2);
	minValue = min(minValue, reduce);

	// Step 5: Get the min/max of the 1st lane
	reduce = LaneSwizzle(minValue, 0x1F, 0x00, 0x1);
	minValue = min(minValue, reduce);

	// Finally, get the minmax of the other group of 32 registers
	minValue = min(ReadLane(minValue, 0), ReadLane(minValue, 32));

	#if REDUCTION_TILE_SIZE >= 16
	uint waveFront = threadGroupIndex / 64;
	s_minValues[waveFront] = minValue;
	ThreadGroupMemoryBarrierSync();

	const uint NUM_WAVEFRONTS = (REDUCTION_TILE_SIZE*REDUCTION_TILE_SIZE)/64;

	for (uint s = NUM_WAVEFRONTS/2; s > 0; s /= 2)
	{
		if (waveFront < s)
		{
			float neighbor = s_minValues[waveFront + s];
			float current = s_minValues[waveFront];
			s_minValues[waveFront] = min(current, neighbor);
		}
		ThreadGroupMemoryBarrierSync();
	}

	minValue = s_minValues[0];
	#endif

	return minValue;
}

// Reduce only within groups of 16 threads
// Only the 0th out of every group has the correct value
// Untested
float2 MinMaxReduce16(uint threadGroupIndex, float minValue, float maxValue)
{
	float minReduce = LaneSwizzle(minValue, 0x1F, 0x00, 0x8);
	float maxReduce = LaneSwizzle(maxValue, 0x1F, 0x00, 0x8);
	minValue = min(minValue, minReduce);
	maxValue = max(maxValue, maxReduce);

	minReduce = LaneSwizzle(minValue, 0x1F, 0x00, 0x4);
	maxReduce = LaneSwizzle(maxValue, 0x1F, 0x00, 0x4);
	minValue = min(minValue, minReduce);
	maxValue = max(maxValue, maxReduce);

	minReduce = LaneSwizzle(minValue, 0x1F, 0x00, 0x2);
	maxReduce = LaneSwizzle(maxValue, 0x1F, 0x00, 0x2);
	minValue = min(minValue, minReduce);
	maxValue = max(maxValue, maxReduce); 

	minReduce = LaneSwizzle(minValue, 0x1F, 0x00, 0x1);
	maxReduce = LaneSwizzle(maxValue, 0x1F, 0x00, 0x1);
	minValue = min(minValue, minReduce);
	maxValue = max(maxValue, maxReduce);

	return float2(minValue, maxValue);
}

// Reduce only within groups of 8 threads
// Only the 0th of every group has the correct value
float2 MinMaxReduce8(float minValue, float maxValue)
{
	float minReduce = LaneSwizzle(minValue, 0x1F, 0x00, 0x4);
	float maxReduce = LaneSwizzle(maxValue, 0x1F, 0x00, 0x4);
	minValue = min(minValue, minReduce);
	maxValue = max(maxValue, maxReduce);

	minReduce = LaneSwizzle(minValue, 0x1F, 0x00, 0x2);
	maxReduce = LaneSwizzle(maxValue, 0x1F, 0x00, 0x2);
	minValue = min(minValue, minReduce);
	maxValue = max(maxValue, maxReduce); 

	minReduce = LaneSwizzle(minValue, 0x1F, 0x00, 0x1);
	maxReduce = LaneSwizzle(maxValue, 0x1F, 0x00, 0x1);
	minValue = min(minValue, minReduce);
	maxValue = max(maxValue, maxReduce);

	return float2(minValue, maxValue);
}

// Reduce only within groups of 8 threads
// Only the 0th of every group has the correct value
float MinReduce8(float minValue)
{
	float minReduce = LaneSwizzle(minValue, 0x1F, 0x00, 0x4);
	minValue = min(minValue, minReduce);

	minReduce = LaneSwizzle(minValue, 0x1F, 0x00, 0x2);
	minValue = min(minValue, minReduce);

	minReduce = LaneSwizzle(minValue, 0x1F, 0x00, 0x1);
	minValue = min(minValue, minReduce);

	return minValue;
}


#endif
