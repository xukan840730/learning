#ifndef KD_TREE_FXI
#define KD_TREE_FXI

static uint		g_traversalMode;
static uint		g_testMode;
static uint		g_kdTreeLevel;

static float2	g_tboundsOut = {0.f, 0.f};
static uint		g_kdStackDepthOut;
static uint		g_kdStackEntryOut;
static uint		g_kdTraversalValue;

static uint		g_kdSelTraversalIndex;
static uint		g_kdSelStackDepth;
static uint		g_kdTraversalIdx;

static float4	g_misc = {0.f, 0.f, 0.f, 0.f};

static uint g_numNode;
static uint g_numLeaf;

static const ushort kInvalidNode = 0x8000;

enum PtTraversalMode
{
	kTravFoley,
	kTravStack
};

enum PtTestMode
{
	kTestSplit,
	kTestBox
};

enum KdTreeSplitAxis
{
	kSplitAxisX,
	kSplitAxisY,
	kSplitAxisZ
};

struct BvhAabb
{
	float3 m_min;
	float3 m_max;
};

struct KdNode
{
	BvhAabb		m_leftBox;
	BvhAabb		m_rightBox;

	float		m_split;
	ushort		m_left;
	ushort		m_right;
	uint		m_axis;

	ushort		m_leftStartPrim;
	ushort		m_rightStartPrim;
};

struct KdMeshPrim
{
	uint							m_objIndex;
	uint3							m_triangleIdx;
};

struct TmpNode
{
	BvhAabb		m_leftBox;
	BvhAabb		m_rightBox;

	uint	m_leftRight;
	uint	m_leftRightStartPrims;
	float	m_split;
	uint	m_axis;
};

struct TmpMeshPrim
{
	uint	m_objT1Idx;
	uint	m_T2T3Idx;
};

struct KdTree
{
	StructuredBuffer<TmpNode>		m_nodes;
	StructuredBuffer<TmpMeshPrim>	m_prims;
	StructuredBuffer<uint>			m_indices;

	float4	m_minPos;
	float4	m_maxPos;
};

bool IsLeaf(uint nodeIndex)
{
	return ((nodeIndex & 0x8000) == 0x8000);
}

// ----------------------------------------------------------------------------
static const float kPathTracerEpsilon = 1e-4f;

KdNode TmpToKdNode(TmpNode tnode)
{
	KdNode knode;

	knode.m_leftBox = tnode.m_leftBox;
	knode.m_rightBox = tnode.m_rightBox;

	knode.m_split = tnode.m_split;
	knode.m_left = (ushort)(tnode.m_leftRight & 0xFFFF);
	knode.m_right = (ushort)(tnode.m_leftRight >> 16);
	knode.m_axis = tnode.m_axis;

	knode.m_leftStartPrim = (ushort)(tnode.m_leftRightStartPrims & 0xFFFF);
	knode.m_rightStartPrim = (ushort)(tnode.m_leftRightStartPrims >> 16);

	return knode;
}

KdMeshPrim	TmpToKdMeshPrim(TmpMeshPrim tprim)
{
	KdMeshPrim prim;

	prim.m_objIndex = (tprim.m_objT1Idx & 0xffff);
	prim.m_triangleIdx = uint3(tprim.m_objT1Idx >> 16, tprim.m_T2T3Idx & 0xffff, tprim.m_T2T3Idx >> 16);

	return prim;
}



static uint	iters = 0;

// ----------------------------------------------------------------------------
// Kd tree
// Stackless implementation - Foley 2005

int		KdGetNextNode_Foley(KdNode node, Ray r, inout float2 tbounds, inout uint startPrim)
{
#ifdef DEBUG
	// TBD stateless BVH traversal!
	if (g_testMode == kTestBox)
	{
		float2 leftHit = RayVsAabb(r, node.m_leftBox.m_min, node.m_leftBox.m_max + kPathTracerEpsilon);
		float2 rightHit = RayVsAabb(r, node.m_rightBox.m_min, node.m_rightBox.m_max + kPathTracerEpsilon);

		bool traverseLeft = leftHit.x < kMaxT;
		bool traverseRight = rightHit.x < kMaxT;

		uint near;

		if (!traverseLeft && !traverseRight)
		{
			return kInvalidNode;
		}
		else
		{
			near = (traverseLeft) ? node.m_left : node.m_right;
			startPrim = (traverseLeft) ? node.m_leftStartPrim : node.m_rightStartPrim;
			if (traverseLeft && traverseRight)
			{
				tbounds.y = rightHit.x + 0.1f;
				if (rightHit.x < leftHit.x)
				{
					tbounds.y = leftHit.x + 0.1f;
					near = node.m_right;
					startPrim = node.m_rightStartPrim;
				}
			}
		}

		return near;
	}
	else
#endif
	{
		float o, d;
		if (node.m_axis == kSplitAxisX)
			{	o = r.pos.x; d = r.dir.x; }
		else if (node.m_axis == kSplitAxisY)
			{	o = r.pos.y; d = r.dir.y; }
		else
			{	o = r.pos.z; d = r.dir.z; }

		uint near, far;
		uint nearStartPrim, farStartPrim;

		if (d > 0.f)
		{
			near = node.m_left;
			far = node.m_right;
			nearStartPrim = node.m_leftStartPrim;
			farStartPrim = node.m_rightStartPrim;
		}
		else if (d < 0.f)
		{
			near = node.m_right;
			far = node.m_left;
			nearStartPrim = node.m_rightStartPrim;
			farStartPrim = node.m_leftStartPrim;
		}
		else
		{
			if (o < node.m_split)
			{
				startPrim = node.m_leftStartPrim;
				return node.m_left;
			}
			else
			{
				startPrim = node.m_rightStartPrim;
				return node.m_right;
			}
		}

		float	hit = (node.m_split - o) / d;

		if (hit <= tbounds.x)
		{
			startPrim = farStartPrim;
			return far;
		}
		else if (hit > tbounds.y)
		{
			startPrim = nearStartPrim;
			return near;
		}
		else
		{
			tbounds.y = hit;
			startPrim = nearStartPrim;
			return near;
		}
	}
}

int	KdGetNextLeaf_Foley(Ray r, KdTree tree, inout float2 tbounds, inout uint pstart, inout uint pcount)
{
	int	currNode = 0;
	KdNode	node = TmpToKdNode(tree.m_nodes[currNode]);
	g_numNode++;

	pstart = 0;
	pcount = 0;

	while (iters < g_kdTreeLevel)
	{
		if (g_kdTraversalIdx <= g_kdSelTraversalIndex)
		{
			g_kdTraversalValue = currNode;
			g_tboundsOut = tbounds;
		}
		g_kdTraversalIdx++;

		uint startPrim = 0;
		int nextNode = KdGetNextNode_Foley(node, r, tbounds, startPrim);
		if (nextNode == kInvalidNode)
		{
			// return an empty leaf
			return 0;
		}
		if (!IsLeaf(nextNode))
		{
			currNode = nextNode;
		}
		else
		{
			g_numLeaf++;
			pstart = startPrim;
			pcount = ~nextNode & 0xffff;
			return currNode;
		}
		node = TmpToKdNode(tree.m_nodes[currNode]);
		g_numNode++;
		iters++;
	}

	return kInvalidNode;
}

// ----------------------------------------------------------------------------
// Kd tree
// Stack implementation

const static uint kStackDepth = 16;

struct KdStack
{
	int	kdStack[kStackDepth>>1];
};

static uint				kdStackRoot = 0;
static uint				kdStackPtr = 0;
//static uint			kdStack[kStackDepth];
groupshared KdStack		kdStacks[64];
static uint				g_kdThreadId;

static float			kdSaveBound[kStackDepth];

void PushStack(int item, float bound)
{
	uint idx = kdStackPtr >> 1;
	if (kdStackPtr & 1)
	{
		uint stackVal = kdStacks[g_kdThreadId].kdStack[idx];
		stackVal = (stackVal & 0xffff) | (item << 16);
		kdStacks[g_kdThreadId].kdStack[idx] = stackVal;
	}
	else
		kdStacks[g_kdThreadId].kdStack[idx] = item;

#ifdef DEBUG
	if (g_testMode == kTestSplit)
	{
		kdSaveBound[kdStackPtr] = bound;
	}
#endif
	kdStackPtr++;
}

int PopStack(inout float bound)
{
	if (kdStackPtr == kdStackRoot)
	{
		return kInvalidNode;
	}
	kdStackPtr--;


	int currNode;

	// psslc can't properly build for ushorts on base ps4 so we have to fake our ushort stack!

	uint idx = kdStackPtr >> 1;
	if (kdStackPtr & 1)
	{
		currNode = kdStacks[g_kdThreadId].kdStack[idx] >> 16;
	}
	else
	{
		currNode = kdStacks[g_kdThreadId].kdStack[idx] & 0xffff;
	}
#ifdef DEBUG
	if (g_testMode == kTestSplit)
	{
		bound = kdSaveBound[kdStackPtr];
	}
#endif
	return currNode;
}

void OpenStack()
{
#ifdef DEBUG
	if (g_traversalMode == kTravStack)
	{
		kdStackRoot = kdStackPtr;
		PushStack(0, kMaxT);
	}
#elif defined STACK
	kdStackRoot = kdStackPtr;
	PushStack(0, kMaxT);
#endif
}

void CloseStack()
{
#ifdef DEBUG
	if (g_traversalMode == kTravStack)
	{
		kdStackPtr = kdStackRoot;
		kdStackRoot = 0;
	}
#elif defined STACK
	kdStackPtr = kdStackRoot;
	kdStackRoot = 0;
#endif
}

int GetStackValue(uint index, inout uint depth)
{
	depth = kdStackPtr;
	int currNode;

	// psslc can't properly build for ushorts on base ps4 so we have to fake our ushort stack!

	uint idx = index >> 1;
	if (index & 1)
	{
		currNode = kdStacks[g_kdThreadId].kdStack[idx] >> 16;
	}
	else
	{
		currNode = kdStacks[g_kdThreadId].kdStack[idx] & 0xffff;
	}

	return currNode;
}

int	KdGetNextNode_Stack(KdNode node, int nodeIndex, Ray r, inout float2 tbounds, inout uint startPrim, bool farLeaf)
{
#ifdef DEBUG
	if (g_testMode == kTestSplit)
	{
		float o, d;
		if (node.m_axis == kSplitAxisX)
			{	o = r.pos.x; d = r.dir.x; }
		else if (node.m_axis == kSplitAxisY)
			{	o = r.pos.y; d = r.dir.y; }
		else
			{	o = r.pos.z; d = r.dir.z; }

		uint near, far;
		uint nearStartPrim, farStartPrim;

		if (d > 0.f)
		{
			near = node.m_left;
			far = node.m_right;
			nearStartPrim = node.m_leftStartPrim;
			farStartPrim = node.m_rightStartPrim;
		}
		else
		{
			near = node.m_right;
			far = node.m_left;
			nearStartPrim = node.m_rightStartPrim;
			farStartPrim = node.m_leftStartPrim;
		}

		float	hit = (node.m_split - o) / d;

		if (hit <= tbounds.x)
		{
			startPrim = farStartPrim;
			return far;
		}
		else if (hit > tbounds.y)
		{
			startPrim = nearStartPrim;
			return near;
		}
		else if (kdStackPtr < kStackDepth)
		{
			// push next node on stack and increment
			if (far & 0x8000)
			{
				far = 0x8000 | nodeIndex;
			}

			PushStack(far, tbounds.y);

			tbounds.y = hit;
			startPrim = nearStartPrim;
			return near;
		}
		else
		{
			return kInvalidNode;
		}
	}
	else
#endif
	{
		float2 leftHit = RayVsAabb(r, node.m_leftBox.m_min, node.m_leftBox.m_max + kPathTracerEpsilon);
		float2 rightHit = RayVsAabb(r, node.m_rightBox.m_min, node.m_rightBox.m_max + kPathTracerEpsilon);

		bool traverseLeft = leftHit.x < tbounds.y;
		bool traverseRight = rightHit.x < tbounds.y;

		uint near, far;
		uint farStartPrim;

		if (!traverseLeft && !traverseRight)
		{
			return kInvalidNode;
		}
		else
		{
			near = (traverseLeft) ? node.m_left : node.m_right;
			startPrim = (traverseLeft) ? node.m_leftStartPrim : node.m_rightStartPrim;
			if (traverseLeft && traverseRight)
			{
				far = node.m_right;
				farStartPrim = node.m_rightStartPrim;

				if (rightHit.x < leftHit.x)
				{
					near = node.m_right;
					startPrim = node.m_rightStartPrim;
					far = node.m_left;
					farStartPrim = node.m_leftStartPrim;
				}

				if (farLeaf)
				{
					// traverse far leaf that was popped off stack
					near = far;
					startPrim = farStartPrim;
				}
				else if (kdStackPtr < kStackDepth)
				{
					// push next node on stack and increment
					if (far & 0x8000)
					{
						far = 0x8000 | nodeIndex;
					}

					PushStack(far, 0.f);
				}
				else
				{
					return kInvalidNode;
				}
			}
			return near;
		}
	}
}

int	KdGetNextLeaf_Stack(Ray r, KdTree tree, inout float2 tbounds, inout uint pstart, inout uint pcount)
{
	float	bound = kMaxT;
	bool	farLeaf = false;

	pstart = 0;
	pcount = 0;
	
	int currNode = PopStack(bound);
	if (currNode == kInvalidNode)
	{
		return kInvalidNode;
	}

	// Stack handling for leaf nodes... if the high bit in the ushort is set,
	// it means we pushed the far leaf of the node and not the node itself
	if (currNode & 0x8000)
	{
		farLeaf = true;
		currNode &= 0x7fff;
	}

#ifdef DEBUG
	if (g_testMode == kTestSplit)
		tbounds.y = bound;
#endif
	KdNode	node = TmpToKdNode(tree.m_nodes[currNode]);
	g_numNode++;

	while (iters < g_kdTreeLevel)
	{
		if (g_kdTraversalIdx <= g_kdSelTraversalIndex)
		{
			g_kdTraversalValue = currNode;
			g_kdStackEntryOut = GetStackValue(g_kdSelStackDepth, g_kdStackDepthOut);
			g_tboundsOut = tbounds;
		}
		g_kdTraversalIdx++;

		uint startPrim = 0;
		int nextNode = KdGetNextNode_Stack(node, currNode, r, tbounds, startPrim, farLeaf);
		if (nextNode == kInvalidNode)
		{
			// return an empty leaf
			return 0;
		}
		if (!IsLeaf(nextNode))
		{
			currNode = nextNode;
		}
		else
		{
			g_numLeaf++;
			pstart = startPrim;
			pcount = ~nextNode & 0xffff;
			return currNode;
		}
		node = TmpToKdNode(tree.m_nodes[currNode]);
		g_numNode++;
		iters++;
	}

	return kInvalidNode;
}

void	StartKdTree()
{
	// for stack implementation
	// Stack is shared between level and inst
	OpenStack();
}

void EndKdTree()
{
	CloseStack();
}

void InitKdTree(uint threadId, 
				uint traversalMode,
				uint testMode,
				uint kdTreeLevel,
				uint kdSelTraversalIndex,
				uint kdSelStackDepth)
{
	g_kdThreadId = threadId;

	g_traversalMode = traversalMode;
	g_testMode = testMode;

#ifndef DEBUG
	kdTreeLevel = 25000;
#endif
	g_kdTreeLevel = kdTreeLevel;
	g_kdSelTraversalIndex = kdSelTraversalIndex;
	g_kdSelStackDepth = kdSelStackDepth;

	g_numNode = 0;
	g_numLeaf = 0;

	g_kdTraversalIdx = 0;
	g_kdStackDepthOut = 0;
	g_kdStackEntryOut = 0;
	g_kdTraversalValue = 0;
}

// ----------------------------------------------------------------------------
int	KdGetNextLeaf(Ray r, KdTree tree, inout float2 tbounds, inout uint pstart, inout uint pcount)
{
	int nodeIndex;

#ifdef DEBUG
	switch (g_traversalMode)
	{
		case kTravFoley:
			nodeIndex = KdGetNextLeaf_Foley(r, tree, tbounds, pstart, pcount);
			break;
		case kTravStack:
		default:
			nodeIndex = KdGetNextLeaf_Stack(r, tree, tbounds, pstart, pcount);
			break;
	}
#elif defined STACK
	nodeIndex = KdGetNextLeaf_Stack(r, tree, tbounds, pstart, pcount);
#else
	nodeIndex = KdGetNextLeaf_Foley(r, tree, tbounds, pstart, pcount);
#endif

	return nodeIndex;
}
	
#endif