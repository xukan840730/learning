//--------------------------------------------------------------------------------------
// File: ssct.fx
//
// Screen-space cone tracing
//
// Traces a cone in screen-space against depth buffer as a height-field, in order to
// compute visibility. 
//
// Copyright (c) Naughty Dog Inc. All rights reserved.
//--------------------------------------------------------------------------------------

#ifndef __SSCT__
#define __SSCT__

#include "packing.fxi"

float GetLinearDepth(in float depthBufferZ, in float4 screenToViewParams0)
{
	return (screenToViewParams0.w / (depthBufferZ - screenToViewParams0.z));
}

// assumes useHeightMap is a compile time static variable
float LoadLinearDepth(in int2 screenCoords, in Texture2D<float> tex_depthWithHeightmap,
					  in float4 screenToViewParams0, in bool useHeightMap)
{
	// When height-map usage is disabled the regular depth buffer is used, which stores native depth. In contrast the
	// combined depth and height-map buffer stores linear depth.
	float depth = tex_depthWithHeightmap[screenCoords].x;
	if (!useHeightMap)
	{
		depth = GetLinearDepth(depth, screenToViewParams0);
	}
	return depth;
}

// assumes useHeightMap is a compile time static variable
float SampleLinearDepth(in float2 texCoords, in Texture2D<float> tex_depthWithHeightmap, in SamplerState samplerInput,
						in float4 screenToViewParams0, in bool useHeightMap)
{
	// When height-map usage is disabled the regular depth buffer is used, which stores native depth. In contrast the
	// combined depth and height-map buffer stores linear depth. 
	float depth = tex_depthWithHeightmap.SampleLevel(samplerInput, texCoords, 0).x;
	if (!useHeightMap)
	{
		depth = GetLinearDepth(depth, screenToViewParams0);
	}
	return depth;
}

float3 GetPositionVS(in float2 texCoords, in float linearDepth, in float4 screenToViewParams0, in float4 screenToViewParams1)
{
	float2 screenSpaceXy = texCoords.xy * float2(2.0f, -2.0f) + float2(-1.0f, 1.0f);
	float2 viewSpaceXy = (screenSpaceXy * screenToViewParams0.xy - screenToViewParams1.xy) * linearDepth;
	return float3(viewSpaceXy, linearDepth);
}

float GetInvW(in float3 positionVS, in float4x4 viewToScreenMat)
{
	return 1.0f / mul(viewToScreenMat, float4(positionVS, 1.0f)).w;
}

float2 GetScreenTC(in float3 positionVS, in float4x4 viewToScreenMat)
{
	float4 positionCS = mul(viewToScreenMat, float4(positionVS, 1.0f));
	return (positionCS.xy / positionCS.w) * float2(0.5f, -0.5f) + float2(0.5f, 0.5f);
}

float2 GetExtScreenTC(in float3 positionVS, in float4x4 viewToScreenMat, out float invW)
{
	float4 positionSS = mul(viewToScreenMat, float4(positionVS, 1.0f));
	invW = 1.0f / positionSS.w;
	positionSS.xy *= invW;
	return positionSS.xy * float2(0.5f, -0.5f) + float2(0.5f, 0.5f);
}

// transforms direction from world to view space
float3 TransformWorldToView(in float3 dirWS, in float3x3 worldToViewMat)
{
	float3 dirVS;
	dirVS.x = dot(worldToViewMat[0].xyz, dirWS);
	dirVS.y = dot(worldToViewMat[1].xyz, dirWS);
	dirVS.z = dot(worldToViewMat[2].xyz, dirWS);
	return dirVS;
}

struct ConeTraceSetup
{
	Texture2D<float> tex_depthWithHeightmap;
	SamplerState pointSampler;
	float2 startPosSS;
	float3 startPosVS;
	float3 normalVS;
	float3 coneTraceDirVS;
	float2 jitterOffset; // (x = direction offset, y = step offset)
	float4 coneTraceParams; // (x = slope, y = start trace distance, z = inverse max contact distance, w = intensity)
	float4 screenToViewParams;
	float4x4 viewToScreenMat;
	float invZoom;
	float fade;
	float depthBias;
	float slopeScaledDepthBias;
	uint sampleCount;
	bool useHeightMap;
};

float ConeTraceVisibility(in ConeTraceSetup setup)
{
	// skip fragments that are back-facing trace direction to avoid overshadowing
	// of translucent surfaces
	float nDotD = dot(setup.normalVS, setup.coneTraceDirVS);
	if (nDotD < 0.0f)
		return 1.0f;

	// start position of cone trace
	float2 startPosSS = setup.startPosSS;
	float3 startPosVS = setup.startPosVS;
	float startInvW = GetInvW(startPosVS, setup.viewToScreenMat);

	// end position of cone trace
	float3 endPosVS = setup.coneTraceDirVS * 0.1f + startPosVS;
	float endInvW;
	float2 endPosSS = GetExtScreenTC(endPosVS, setup.viewToScreenMat, endInvW);

	// cone trace direction in screen-space
	float2 coneDir = endPosSS - startPosSS;
	float invConeDirLength = 1.0f / length(coneDir);
	coneDir *= invConeDirLength;

	// direction perpendicular to cone trace direction
	float2 perpConeDir = float2(coneDir.y, -coneDir.x);

	// avoid self-occlusion and reduce banding artifacts by normal variation
	float3 viewVecVS = normalize(startPosVS);
	float minTraceDistance = (1.0f - abs(dot(setup.normalVS, viewVecVS))) * 0.005f;

	// init trace distance and sample radius
	float invLinearDepth = 1.0f / setup.startPosVS.z;
	float traceDistance = max(setup.coneTraceParams.y, minTraceDistance) * invLinearDepth;
	float sampleRadiusSS = setup.coneTraceParams.x * traceDistance;
	float endRadiusSS = setup.coneTraceParams.x / invConeDirLength;
	float endRadiusVS = endRadiusSS * setup.invZoom * invLinearDepth / endInvW;

	// calculate depth bias
	float depthBias = saturate(1.0f - nDotD) * setup.slopeScaledDepthBias + setup.depthBias;

	float occlusion = 0.0f;
	for (uint i = 0; i < setup.sampleCount; i++)
	{
		// step along cone in screen space
		float newSampleRadiusSS = sampleRadiusSS * (sampleRadiusSS + traceDistance) / (traceDistance - sampleRadiusSS);
		float stepDistance = sampleRadiusSS + newSampleRadiusSS;
		sampleRadiusSS = newSampleRadiusSS;

		// apply jitter offset
		float jitterDistance = stepDistance * setup.jitterOffset.y;
		float jitteredTracedDistance = traceDistance + jitterDistance;
		float jitteredSampleRadius = setup.jitterOffset.x * sampleRadiusSS * jitterDistance / stepDistance;

		// sample depth buffer
		float2 samplePosSS = perpConeDir * jitteredSampleRadius + coneDir * jitteredTracedDistance + startPosSS;
		float bufferDepthValue = SampleLinearDepth(samplePosSS, setup.tex_depthWithHeightmap, setup.pointSampler,
												   setup.screenToViewParams, setup.useHeightMap);

		// calculate depth of cone center
		float ratio = jitteredTracedDistance * invConeDirLength;
		float lerpedW = 1.0f / lerp(startInvW, endInvW, ratio);
		float sampleDepth = lerpedW;

		// calculate depth range of cone slice
		float sampleRadiusVS = endRadiusVS * ratio * lerpedW;
		float jitteredSampleRadiusVS = sampleRadiusVS * setup.jitterOffset.x;
		float sliceHalfRangeVS = fastSqrtNR0(sampleRadiusVS * sampleRadiusVS + jitteredSampleRadiusVS * jitteredSampleRadiusVS);
		float sampleDepthMin = sampleDepth - sliceHalfRangeVS;
		float sampleDepthMax = sampleDepth + sliceHalfRangeVS;

		// calculate overlap of depth buffer height-field with trace cone
		float depthDifference = sampleDepthMax - bufferDepthValue;
		float overlap = saturate((depthDifference - depthBias) / (sampleDepthMax - sampleDepthMin));

		// attenuate by distance to avoid false occlusion
		float attenuation = saturate(1.0f - (depthDifference * setup.coneTraceParams.z));
		occlusion = max(occlusion, overlap * attenuation);

		if (occlusion >= 1.0f)
			break;

		traceDistance += stepDistance;
	}
	
	return saturate(1.0f - occlusion * setup.coneTraceParams.w * setup.fade);
}

#endif
