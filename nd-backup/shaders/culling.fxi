#ifndef __CULLING_FXI__
#define __CULLING_FXI__

void ObbToAabb(in float3 center, in float3 scaledXAxis, in float3 scaledYAxis, in float3 scaledZAxis,
			   out float3 aabbMin, out float3 aabbMax)
{
	float3 rotExtents;
	for (uint i = 0; i < 3; i++)
		rotExtents[i] = abs(scaledXAxis[i]) + abs(scaledYAxis[i]) + abs(scaledZAxis[i]);
	aabbMin = center - rotExtents;
	aabbMax = center + rotExtents;
}

bool AabbAabbOverlap(in float3 aabbMinA, in float3 aabbMaxA, in float3 aabbMinB, in float3 aabbMaxB)
{
	for (uint i = 0; i < 3; i++)
	{
		if ((aabbMinA[i] > aabbMaxB[i]) || (aabbMinB[i] > aabbMaxA[i]))
			return false;
	}
	return true;
}

bool AabbSphereOverlap(in float3 aabbMin, in float3 aabbMax, in float3 sphereCenter, in float sphereRadius)
{
	float3 dist = max(max(aabbMin - sphereCenter, sphereCenter - aabbMax), 0.0f);
	return dot(dist, dist) <= (sphereRadius * sphereRadius);
}

bool FrustumSphereOverlap(in float4 frustumPlanes[], in uint numFrustumPlanes,
						  in float3 sphereCenter, in float sphereRadius)
{
	for (uint i = 0; i < numFrustumPlanes; i++)
	{
		float distanceToPlane = dot(frustumPlanes[i].xyz, sphereCenter) - frustumPlanes[i].w;
		if (distanceToPlane < -sphereRadius)
			return false;
	}
	return true;
}

bool FrustumObbOverlap(in float4 frustumPlanes[], in uint numFrustumPlanes, in float3 obbCenter,
					   in float3 obbScaledXAxis, in float3 obbScaledYAxis, in float3 obbScaledZAxis)
{
	for (uint i = 0; i < numFrustumPlanes; i++)
	{
		// compute the projection onto the separating axis
		float projInterval = abs(dot(frustumPlanes[i].xyz, obbScaledXAxis)) + 
							 abs(dot(frustumPlanes[i].xyz, obbScaledYAxis)) +
							 abs(dot(frustumPlanes[i].xyz, obbScaledZAxis));

		// then the distance from the center to the plane
		float dist = dot(float4(obbCenter, -1.0f), frustumPlanes[i]);

		if (dist <= -projInterval)
			return false;
	}
	return true;
}

bool FroxelSphereOverlap(in float3 froxelAabbMin, in float3 froxelAabbMax, in float4 froxelSidePlanes[],
						 in float3 sphereCenter, in float sphereRadius)
{
	// Start with AABB - sphere overlap test.
	if (!AabbSphereOverlap(froxelAabbMin, froxelAabbMax, sphereCenter, sphereRadius))
		return false;
	
	// Refine by frustum - sphere overlap test.
	// Note that this alone is inefficient for testing small frustums against large spheres.
	// We don't need to test for near / far frustum plane, since this is already done in the AABB -
	// sphere overlap test.
	return FrustumSphereOverlap(froxelSidePlanes, 4, sphereCenter, sphereRadius);
}

bool FroxelObbOverlap(in float3 froxelAabbMin, in float3 froxelAabbMax, in float4 froxelSidePlanes[],
					  in float3 obbCenter, in float3 obbScaledXAxis, in float3 obbScaledYAxis,
					  in float3 obbScaledZAxis)
{
	float3 aabbMin, aabbMax;
	ObbToAabb(obbCenter, obbScaledXAxis, obbScaledYAxis, obbScaledZAxis, aabbMin, aabbMax);

	// Start with AABB - AABB overlap test.
	if (!AabbAabbOverlap(froxelAabbMin, froxelAabbMax, aabbMin, aabbMax))
		return false;

	// Refine by frustum - OBB overlap test.
	// Note that this alone is inefficient for testing small frustums against large OBBs.
	// We don't need to test for near / far frustum plane, since this is already done in the AABB -
	// AABB overlap test.
	return FrustumObbOverlap(froxelSidePlanes, 4, obbCenter, obbScaledXAxis, obbScaledYAxis, obbScaledZAxis);
}

#endif
