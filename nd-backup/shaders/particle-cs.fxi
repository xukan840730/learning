/*
 * Copyright (c) 2014 Naughty Dog, Inc.
 * A Wholly Owned Subsidiary of Sony Computer Entertainment, Inc.
 * Use and distribution without consent strictly prohibited
 */

 #ifndef PARTICLE_CS_H
 #define PARTICLE_CS_H

#include "compressed-vsharp.fxi"

#define kMaxNumCachedFieldStates 8

#define kMaxParticleCount 2048

#define kMaxFeedBackEvents 1024 // 512
#define kMaxTrackedObjects 512


#define RIBBON_TRACK_MOTION_ON_BIND_POSE 1

#define COMPUTE_FEATURE_FG_ONLY (1 << 0)
#define COMPUTE_FEATURE_BG_ONLY (1 << 1)
#define COMPUTE_FEATURE_COLLISION (1 << 2)
#define COMPUTE_FEATURE_SURFACE_SNAP (1 << 3)
#define COMPUTE_FEATURE_VELOCITY_FACING (1 << 4)
#define COMPUTE_FEATURE_ONLY_ON_CHARACTERS (1 << 5)
#define COMPUTE_FEATURE_EXCLUDE_CHARACTERS (1 << 6)
//#define COMPUTE_FEATURE_GENERATE_COLLISION_EVENTS (1 << 7)
#define COMPUTE_FEATURE_GENERATE_BLOOD_MAP_EVENTS (1 << 8)
#define COMPUTE_FEATURE_SLIDE_ON_COLLISION (1 << 9)
#define COMPUTE_FEATURE_SCREEN_MOTION_FORCE (1 << 10)
#define COMPUTE_FEATURE_BLOOD_MAP_WASH_OUT (1 << 11)
#define COMPUTE_FEATURE_GENERATE_COLLISION_EVENTS_POOL_DECAL (1 << 12)
#define COMPUTE_FEATURE_GENERATE_COLLISION_EVENTS_GEO_RIBBON (1 << 13)
#define COMPUTE_FEATURE_RANDOM_START_INDEX (1 << 14)
#define COMPUTE_FEATURE_RANDOM_CHANNEL_PICK (1 << 15)
#define COMPUTE_FEATURE_RANDOM_SPRITE_TWIST (1 << 16)
#define COMPUTE_FEATURE_KEEP_SIMULATING_OUTSIDE_OF_VIEW (1 << 17)
#define COMPUTE_FEATURE_SPAWN_FROM_PARTICLES (1 << 18)
#define COMPUTE_FEATURE_VELOCITY_FACING_2D (1 << 19)
#define COMPUTE_FEATURE_SPAWN_FROM_EMITTER_HINTS (1 << 20)
#define COMPUTE_FEATURE_HINTS_FROM_COLLISION (1 << 21)
#define COMPUTE_KILL_ON_COLLISION (1 << 22)
#define COMPUTE_FEATURE_CRAWLER_BEHAVIOR (1 << 23)
#define COMPUTE_FEATURE_VELOCITY_ORIENT_BLEND (1 << 24)
#define COMPUTE_FEATURE_DISABLE_SCALE_CULL (1 << 25)
#define COMPUTE_FEATURE_DISABLE_OCCLUSION_CULL (1 << 26)
#define COMPUTE_FEATURE_REQUIRE_BLOOD_MAP_AT_SPAWN_LOCATION (1 << 27)
#define COMPUTE_FEATURE_ALLOW_DIFFERENT_RIBBON_TYPES (1 << 28)
#define COMPUTE_FEATURE_SPAWN_FILTER_ON_WATER (1 << 29)
#define COMPUTE_FEATURE_SEND_SOUND_EVENTS (1 << 30)
#define COMPUTE_FEATURE_SEND_PLAYER_SPLASH_EVENT (1 << 31)




#define WATER_STENCIL_BIT 0x2

// this is a struct that represents final renderable particle isntance. TODO: we need to get it from a particle shader, not copied here!
struct ParticleInstance
{
	float4x4 world;			// The object-to-world matrix
	float4x4 prevWorld;		// Last frame's object-to-world matrix
	float4   color;			// The particle's color
	float4   texcoord;		// Texture coordinate scale and bias (uv = uv0 * texcoord.xy + texcoord.zw)
	float4   userh;			// User attributes (used to be half data type)
	float4   userf;			// User attributes
	float4   partvars;		// Contains age, normalized age, ribbon distance, and frame number
	float4   invscale;		// Reciprocal of the particle's half-scale vector
};

struct Particle
{
	uint	m_time;		// Measured in timeframes, wraps at 170 days!
	uint	m_flags;
	uint	m_particleSeed_m_seed;	// bits 16-31 Random seed used to evaluate the state of the particle, set at spawn and does not change.
								// bits 0-15 Random seed that changes each time a random value is generated using it; initially set using the particle seed
	uint	m_partIdx_m_lastIdx;	// bits 16-31 Index of spawned particle within effect, or pool index
								// bits 0-15 This particle's index in its block last frame, or -1 if it did not exist last frame.

	float4	m_pos;
	float4	m_vel;
};


struct ParticleEmitterData
{
	float			m_lifespan;
	uint			m_spawnTime;			// Time to evaluate the next spawn from. 
	uint			m_emitterSeed_m_spawnSeed;	// bits 16-31 Random seed used to update the state of the emitter, set at spawn and does not change
											// bits 0-15 Random seed used to set particle seed, changes with each emitted particle.
	uint			m_pad;

	float4		m_rot; // Quat
	float4		m_lastLocPos;
	float4		m_lastLocRot; // Quat
};

struct EmitterState
{
	float3		spawnPos;
	float		m_pad0;
	float3		spawnRot;
	float		m_pad1;
	float3		spawnScale;			// volume only
	float		m_pad2;
	float3		direction;
	float		m_pad4;

	float			spawnRate;
	float			lifespanBase;
	float			lifespanRandom;
	float			speedRandom;

	float			speedBase;			// Point only
	float			spread;				// Point only
	float			minDist;			// Point only
	float			maxDist;			// Point only

	float			sweep;				// Volume only
	float			randomDirSpeed;		// Volume only
	float			dirSpeed;			// Volume only
	float			awayCenterSpeed;	// Volume only
	float			awayAxisSpeed;		// Volume only
	float			alongAxisSpeed;		// Volume only
	float			aroundAxisSpeed;	// Volume only
	float			sectionRadius;		// Volume only
};


// static dcx emitter data
#define kPointEmitter 0x0
#define kVolumeEmitter 0x1
#define kLargeEmitter 0x2

#define kPointEmitterTypeOmni 0x0
#define kPointEmitterTypeDirectional 0x1

#define kVolumeEmitterShapeCube 0x0
#define kVolumeEmitterShapeSphere 0x1
#define kVolumeEmitterShapeCylinder 0x2
#define kVolumeEmitterShapeCone 0x3
#define kVolumeEmitterShapeTorus 0x4

#define kPartSpawnModeNormal 0
#define kPartSpawnModeBurst 1
#define kSpawnModeDistance 2
#define kSpawnModeManual 3

struct EmitterNode
{
	uint m_nodeId;
	uint m_lifespanMode;
	float m_lifespan;
	float m_lifespanRandom;
	uint m_script;
};

/// --------------------------------------------------------------------------------------------------------------- ///
struct PointEmitterNode : EmitterNode
{
	uint m_type;
	uint2 m_pad2;
	float4 m_spawnPos;
	float4 m_spawnRot;
	float4 m_direction;
	float m_spread;
	float m_minDist;
	float m_maxDist;
	float m_speed;
	float m_speedRandom;
	uint3 m_pad3;
};

/// --------------------------------------------------------------------------------------------------------------- ///
struct VolumeEmitterNode : EmitterNode
{
	uint m_shape;
	float m_sweep;
	float m_sectionRadius;
	float4 m_spawnPos;
	float4 m_spawnRot;
	float4 m_spawnScale;
	float4 m_direction;
	float m_speedRandom;
	float m_randomDir;
	float m_dirSpeed;
	float m_awayCenter;
	float m_awayAxis;
	float m_alongAxis;
	float m_aroundAxis;
	float m_pad;
};

/// --------------------------------------------------------------------------------------------------------------- ///
struct LargeEmitterNode : VolumeEmitterNode
{
	float m_cameraRadius;
	uint3 m_pad;
};

struct MaxEmitterNode
{
	// start of EmitterNode
	uint m_nodeId;
	uint m_lifespanMode;
	float m_lifespan;
	float m_lifespanRandom;

	float4 m_data[8];
};


struct ParticleFadeRange
{
	float m_fadeInStart;
	float m_fadeInEnd;
	float m_fadeOutStart;
	float m_fadeOutEnd;
};

struct ParticleUpdateData
{
	float m_lifespan;
	uint m_poolIdx_m_spawnMode; // u16
	//PartSpawnMode m_spawnMode = kPartSpawnModeNormal; // u16

	//PartChildSpawnMode m_childSpawnMode; // u16
	//ChildSpawnFlags m_childSpawnFlags; // u8
	//U8 m_numChildRootVars;
	uint m_childSpawnMode_m_childSpawnFlags_m_numChildRootVars;

	float m_childSpawnParam;
	uint2 m_childSpawnSidTable;
	uint2 m_childRootVars;
	uint m_childFacing; // u32
	ParticleFadeRange m_emitFadeRange;
	float m_updatePauseDist;
	float m_manualSpawnNoSpawnRadius;
	float m_fieldStrengths[9];
};

struct CustomParticleData
{
	float4 m_vec0; // spriteScale XYZ , spriteScaleRandom
	float4 m_vec1; // lifespan, lifespanRandom, bounceStrength, slideDrag
	float4 m_vec2; // flipbook fps, opacity fade in, out, none
	float4 m_vec3; // distance fade in start, end, fade out start, end
	float4 m_vec4; //
	float4 m_vec5; //
	float4 m_vec6; //
	float4 m_vec7; //
	int4 m_intVec0;
	int4 m_intVec1;
};

struct CompleteEmitterState
{
	PointEmitterNode		*m_pPointEmitter;
	VolumeEmitterNode		*m_pVolumeEmitter;
	LargeEmitterNode		*m_pLargeEmitter;
	uint2					m_pad;

	MaxEmitterNode			m_emitterNodeData;
	ParticleUpdateData		m_updateData;

	Particle				m_emitterParticleState;
	ParticleEmitterData		m_particleEmitterData;
	EmitterState			m_computeEmitterState;
};

#define kNullField 0
#define kDragField 1
#define kGravityField 2
#define kAirField 3
#define kRadialField 4
#define kVortexField 5
#define kVolumeAxisField 6
#define kTurbulenceField 7
#define kKillField 8

struct FieldState
{
	// Script accessible fields
	float4		pos;
	float4		rot;
	float4		scale;

	float4		direction; 			// drag, gravity, air, volumeaxis
	float4		axis;				// vortex
	float4		phase;				// turbulence

	float 		magnitude;
	float 		attenuation;
	float 		maxDist;

	float 		speed;				// air
	float 		spread;				// air
	float 		radialType;			// radial

	float 		dirSpeed;			// volumeaxis
	float 		awayCenter;			// volumeaxis
	float 		awayAxis; 			// volumeaxis
	float 		alongAxis; 			// volumeaxis
	float 		aroundAxis;			// volumeaxis

	float 		freq;				// turbulence

	// 9 x float4

	uint		shape;
	uint		flags;
	uint		invertAttenuation;	// volumeaxis

	uint		nodeId_fieldClass;

	float4x4	fieldTestMat;
	float4 		fieldPos;
	float		radius;
	float		invMaxDist;			// 1.0f / maxDist
	float2		m_pad;

	// 16 x float4
};

// this is a mirror version of the struct from C++ side, if we change it here, we need to change it on C++ side too

struct SnowParticleState
{
	float3 m_pos;
	uint   m_flags0;
	float3 m_direction;
	uint   m_flags1;
	float3 m_rotation;
	uint   m_id;
	float  m_birthTime;
	float  m_speed;
	float m_lifeTime;
	float m_data;
};

struct TestParticleState
{
	float3 m_pos;
	uint   m_flags0;
	float3 m_velocity;
	uint   m_flags1;
	float3 m_rotation;
	uint   m_id;
	float  m_birthTime;
	float  m_speed;
	float m_lifeSpan;
	float m_data;
};


struct GenericParticleState
{
	float3 m_pos;
	uint   m_flags0;
	float3 m_velocity;
	uint   m_flags1;    // packed: rand value 1 + rand value 2
	float3 m_rotation;
	uint   m_flags2;   // error tracking
	float  m_birthTime;
	float  m_speed;
	float  m_lifeSpan;  // packed: Lifespan + stored Alpha
	uint  m_data;		// packed: SpriteTwist + Acceleration Bend
};

struct HintEmitterInfo
{
	float3 pos;
	float3 scale;
	float3x3 rotation;
	float rate;
	float3 direction;
	float spread;
	float speed;
	float speedRandom;
	float awayFromCenter;
	float lifespan;
	float alpha;
};

struct GenericEmitterHint
{
	float3 m_pos;
	float  m_rate;
	float3 m_scale;
	uint   m_rotation;
	float4 m_data0;
	float4 m_data1; 
	//float3x3 m_partMat3x3;
};

struct GenericParticleHint
{
	float3 m_pos;
	uint   m_flags0;
	float3 m_velocity; 
	float  m_alpha;
	float4 m_data1;
	float4 m_data2;
};

struct ParticleStateV0
{
	float3 m_pos;
	uint   m_flags0;
	float3 m_scale;
	uint   m_flags1;
	float3 m_rotation;
	uint   m_id;
	float  m_birthTime;
	float  m_speed;
	float m_lifeTime;
	float m_data;
};

/*
For ribbons
struct ParticleStateV0
{
	float3 m_pos; // position
	uint   m_flags0; // state flags
	float3 m_scale; // store frame to frame velocity
	uint   m_flags1; // stencil  // 8 // render mask // material mask
	float3 m_rotation; // local space bind pose when TRACK_BIND_POSE is set
	uint   m_id;
	float  m_birthTime;
	float  m_speed; // could store uvs or indexes (uv0 or uv1) (index0, index 1)
	float m_lifeTime; // low 16 bits lifetime // high bit could stick age into here. right now store index2
	float m_data; // low bits distance to next element // high bits store blood amount
};

// to store triangle information we need
U16 U16 U16 for 3 indices
U16 for barycentric a b (8B each)
U16 for mesh identifier U16 extra
total 3 u32


*/

struct RibbonSpawnHint
{
	float3 m_pos;
	uint   m_flags0;
	uint3 m_packedm0xyzm1xyz;
	uint3 m_packedm2xyzsxyz;
	uint2 m_packedColor;
	uint m_type1_spawnerId16; // spawner id can go up to 512
	uint m_numActive; // we only need 4 bits .. number of active ribbons with this spawner id
	float m_age;
	uint m_uniqueId;
};

struct ParticleFeedBackData
{
	uint4 m_data0;
	float4 m_data1;
	float4 m_data2;
	float4 m_data3;
};

#define kFeedBackTypeSpawnBloodDecal 1
#define kFeedBackTypeAdvanceRibbon 2
#define kFeedBackTypeDebug 3
#define kFeedBackTypeSpawnBloodProjectedDecal 4
#define kFeedBackTypeGrowBloodProjectedDecal 5

#define kFeedBackTypeDebugCross 6

#define kFeedBackTypeDebugStickyParticle 7

#define kFeedBackTypeDebugStickyParticleCopyToStatic 8

#define kFeedBackTypeDebugKillStickyParticleAfterCopy 9

#define kFeedBackTypeDebugStickyParticleFailReason 10

#define kFeedBackTypeDebugProbeData 11


#define kFeedBackTypeDebugProbeFroxel 12
#define kFeedBackTypeDebugProbeFroxelBox 13
#define kFeedBackTypeDebugProbeState 14
#define kFeedBackTypeDebugProbeResult 15
#define kFeedBackTypeDebugProbeDepthVaraince 16
#define kFeedBackTypeDebugProbeDepthVarainceNew 17
#define kFeedBackTypeDebugProbeOcclusionFail 18
#define kFeedBackTypeDebugProbeColorVaraince 19

#define kFeedBackTypeDebugStickyParticleNew 20
#define kFeedBackTypeDebugStickyParticleDie 21

#define kFeedBackTypeDebugStickyParticleNewRibbon 22
#define kFeedBackTypeDebugStickyParticleTracking 23
#define kFeedBackTypeDebugSetSentinel 24

#define kFeedBackTypeSoundSpawnWithRay 25

#define kFeedBackTypeDebugStickyParticlePostUpdate 26

#define kFeedBackTypeSpawnParticle 27
#define kFeedBackTypeDebugStickyParticleRecomputed 28
#define kFeedBackTypeDebugStickyParticleNewBaryData 29
#define kFeedBackTypeDebugStickyParticleBaryRemap 30

struct ParticleFeedBackHeaderData
{
	uint m_numResults;
	float m_data0[3];
};

struct ParticleData
{
	float4 m_data0;
	float4 m_data1;
	float4 m_data2;
	float4 m_data3;
	
	int4 m_data4;
	float4 m_data5;
	float4 m_data6;
	float4 m_data7;
};

struct ParticleDataArray
{
	float m_data[4 * 8];
};

struct RibbonHintData
{
	float m_softSpawnTime;
	float m_hardSpawnTime;
	uint m_uniqueId;
	uint m_pad;
};

struct ParticleDataRibbonHints
{
	RibbonHintData m_datas[8];
};

struct ComputeParticleDebugData
{
	int m_prevIndex;
};


struct PartRtSrt
{
	Texture2D<float4>		m_textures[128];
};


// read gds counter, write the result into destination
struct ParticleComputeJobDispatchIndirectPrepareSrt
{
	RWBuffer<uint3> m_dispathInidrectArgs;
	uint	m_gdsOffsetCounter;
};


struct ObjectIdMappedData
{
	uint m_bodyPart8_objectId24;
	uint m_meshId16_subMeshId8_rtId8; // m_instanceId;
	uint m_numVertices;
	uint m_processId;

	float4x4 m_objToWorld;

	Buffer<uint> m_indexBuffer;
	CompressedVSharp m_vertexBuffer;
	CompressedVSharp m_texCoordBuffer;
	CompressedVSharp m_bindPoseVertexBuffer;
};

uint GetRtId(ObjectIdMappedData d)
{
	return (d.m_meshId16_subMeshId8_rtId8 & 0x000000ff);
}
uint GetMeshId(ObjectIdMappedData d)
{
	return (d.m_meshId16_subMeshId8_rtId8 >> 8);
}

uint GetObjectId(ObjectIdMappedData d)
{
	return (d.m_bodyPart8_objectId24 & 0x00FFFFFF);
}

uint GetBodyPart(ObjectIdMappedData d)
{
	return (d.m_bodyPart8_objectId24 >> 24) & 0x000F;
}

uint GetProcessType(ObjectIdMappedData d)
{
	return (d.m_bodyPart8_objectId24 >> 28) & 0x000F;
}


struct ParticleReferenceData
{
	uint4 m_handleData;
	float3 m_posWs;
	float m_pad;
	float4x4 m_wsToRootSpaceXform;
};


struct ParticleEmitterEntry
{
	float3x3 m_rot;
	float3 m_scale;
	float3 m_pos;
	float m_rate;
	float m_lifespan;
	float m_alpha;
	
	float3 m_offsetVector; //m_gpuVector0

	uint m_uniqueId16;

	float m_pad[10];
};


struct CommonParticleComputeSrt
{
	SamplerComparisonState	m_shadowSampler;

	float4		m_occlusionParameters[3];
};

struct ParticleComputePassDataSrt
{
	float4x4				g_mVP;
	float4x4				m_mLastFrameVP;
	float4x4				g_mVPInv;
	float4x4				m_mAltVPInv; //16
	float4x4				m_mLastFrameVPInv;
	float4x4				m_mLastFrameAltVPInv;

	Texture2D<float>		m_primaryDepthTexture;
	Texture2D<uint>			m_primaryStencil;
	Texture2D<float>		m_opaquePlusAlphaDepthTexture;
	Texture2D<uint>			m_opaquePlusAlphaStencil;
	Texture2D<float2>		m_motionVector;
	Texture2D<float>		m_lastFrameOpaquePlusAlphaDepthTexture;
	Texture2D<uint>			m_lastFrameOpaquePlusAlphaStencil;
	Texture2D<uint>			m_lastFramePrimaryStencil;
	Texture2D<float>		m_lastFramePrimaryDepth;
	Texture2D<float4>		m_lastFramePrimaryFloat;
	Texture2D<float>		m_renderSnapshotDepthTexture;

	Texture2D<uint4>		m_gbuffer0;
	Texture2D<uint4>		m_gbuffer1;
	Texture2D<uint>			m_materialMaskBuffer;
	Texture2D<uint2>		m_objectId;
	Texture2D<float>		m_rainOccluders;
	Texture2DArray<float>   m_sunShadowTexture;
	Texture3D<float4>		m_fogAccumTexture;

	RWStructuredBuffer<ParticleFeedBackData>		m_particleFeedBackData;
	RWStructuredBuffer<ParticleFeedBackHeaderData>	m_particleFeedBackHeaderData;
	StructuredBuffer<ObjectIdMappedData>			m_objectIdMappings;					//16
	StructuredBuffer<ParticleReferenceData>			m_particleMappings;						//16

	uint*											m_pNumObjIdMappings;
	uint*											m_pNumParticleMappings; // 8
};

struct TempSortStruct
{
	uint m_numInstances;
	uint m_offset;
};

struct ParticleComputeJobSrt
{
	RWTexture2D<float4>		m_destTexture0;
	RWTexture2D<float4>		m_destTexture1;
	Texture2D<float4>		m_materialTexture0;
	Texture2D<float4>		m_materialTexture1;

	Texture2D<float4>		m_shTexture1;
	Texture2D<float4>		m_shTexture2;

	//SunShadowConstants g_sunShadowConstants;

	RWStructuredBuffer<ParticleInstance> m_particleInstances;
	RWBuffer<uint> m_particleIndices;
	RWBuffer<uint> m_particleTempIndices;
	RWStructuredBuffer<TempSortStruct> m_particleTempSortData; // a struct for each group
	
	RWStructuredBuffer<ParticleStateV0> m_particleStates;
	RWStructuredBuffer<ParticleStateV0> m_particleStatesOld;
	RWStructuredBuffer<ParticleStateV0> m_particleStatesOther;
	StructuredBuffer<ParticleEmitterEntry> m_cpuEmitterList;
	RWStructuredBuffer<ParticleData> m_dataBuffer;
	StructuredBuffer<ParticleInstance>	m_particleInstancesOrig;
	Buffer<uint>						m_particleIndicesOrig;

	StructuredBuffer<ParticleInstance>	m_particleInstancesOther;
	Buffer<uint>						m_particleIndicesOther;

	RWStructuredBuffer<ParticleFeedBackData> m_particleFeedBackData;
	RWStructuredBuffer<ParticleFeedBackHeaderData> m_particleFeedBackHeaderData;

	RWStructuredBuffer<ComputeParticleDebugData> m_particleDebug;
	
	StructuredBuffer<ObjectIdMappedData>		m_objectIdMappings; //16
	uint4						m_globalVertBuffer;
	uint						*m_pNumObjIdMappings;
	CustomParticleData			*m_pCpuEmitterComputeCustomData;

	CommonParticleComputeSrt*		m_pCommonParticleComputeSrt; // 8
	ParticleComputePassDataSrt*		m_pPassDataSrt;// 8

	uint						m_isNeoMode;
	uint3						m_pad1951;

	StructuredBuffer<ParticleReferenceData>	m_particleMappings; //16
	uint*				m_pNumParticleMappings; // 8
	uint2					m_pad1952;

	//Texture2D<float4>		m_spriteNormal;
	SamplerState			m_linearSampler;

	float4x4			m_rootMatrixWs;
	float4x4			m_rootSpawnerScaleMatrix;
	float4x4			m_rootEffectScaleMatrix;

	float4				m_rootColor;
	float4				m_rootSpriteScale;

	CompleteEmitterState *m_emitterStates[4];

	FieldState	m_fieldStates[kMaxNumCachedFieldStates];
	
	uint				m_numFields;
	uint				m_numEmitterStates;
	uint				m_features;
	uint				m_features2;

	uint				m_frameNumber;
	uint3				m_pad2123;

	uint				m_gdsOffsetCounterNew;
	uint				m_gdsOffsetCounterOld;
	uint				m_gdsOffsetOther;
	uint				m_gridCellW;
	
	uint				m_gridCellH;
	uint				m_gameTicks;  // use for random
	uint				m_gameStateOtherSize;
	float				m_delta;

	uint				m_gdsOffsetIdCounter;
	uint				m_gdsOffsetOtherUseCases;
	uint				*m_pNumOtherBufferUses;

	float				m_lastFrameDelta;
	float2				m_projectionJitterOffsetsDiv;
	float				m_isCameraUnderwater;
	
	float4				m_projectionJitterOffsets;
	
	float4					m_cameraPosWs;
	float4					m_cameraDirWs;
	float4					m_lastFrameCameraPosWs;
	float4x4				m_renderSnapshotMVP;
	float4x4				m_renderSnapshotMVPInv;
	float4					m_renderSnapshotCameraPosWs;
	float4					m_rainDir;
	float4					m_renderOffset;

	CustomParticleData		*m_pComputeCustomData;
	PartRtSrt				*m_pParticleRTs;

	uint					m_rootId;
	uint					m_rootUniqueid;
	float2					m_pad530;

	float3					m_rootComputeVec0;
	float3					m_rootComputeVec1;
	float3					m_rootComputeVec2;
	float3					m_rootComputeVec3;
	float3					m_rootComputeVec4;
	float3					m_rootComputeVec5;
	float3					m_rootComputeVec6;
	float3					m_rootComputeVec7;

	float4					m_sh3dTestLightDir;
	float4					m_sh3dControls;

	float3					m_altWorldOrigin;
	float					m_alphaThreshold;
	float3					m_lastFrameAltWorldOrigin;
	float					m_fogGridOffset;
	
	float2					m_depthParams;
	float2					m_renderSnapshotDepthViewdepthParams;
	float2					m_screenResolution;
	float					m_fovScale;
	float					m_invFovScale;

	uint					m_flags;
	float					m_time;
	float					m_alphaResDropThreshold;
	uint					m_isPlayerFlashlightOn;

	//DummySrt				m_dummySrt;

};

float GetLinearDepth(float z, float2 params)
{
	return params.y / (z - params.x);
}


float4x4 TransformFromLookAt(float3 fwdDir, float3 upDir, float3 pos, bool preserveFwd)
{
	float3 fVec = fwdDir;
	float3 uVec = upDir;

	float3 rVec = normalize(cross(uVec, fVec));


	uVec = preserveFwd ? (cross(fVec, rVec)) : uVec;
	fVec = preserveFwd ? fVec : (cross(rVec, uVec));
		
	float4x4 mat;
	mat[0].xyzw = float4(rVec, 0);
	mat[1].xyzw = float4(uVec, 0);
	mat[2].xyzw = float4(fVec, 0);
	mat[3].xyzw = float4(pos, 1);

/*
	// exact copy of c++ function
	float3 fVec = normalize(fwdDir+float3(0,kEpsilon,0));
	float3 uVec = normalize(upDir+float3(0,0,kEpsilon));

	bool parallel = abs(dot(fVec, float3(1,0,0))) >= 0.999f;
	float3 xAxis = !parallel ? float3(1,0,0) : float3(0,1,0);

	float3 rVec = normalize(cross(uVec, fVec)+float3(kEpsilon,0,0));
	uVec = preserveFwd ? normalize(cross(fVec, rVec)) : uVec;
	fVec = preserveFwd ? fVec : normalize(cross(rVec, uVec));
	
	float4x4 mat;
	mat[0].xyzw = float4(rVec, 0);
	mat[1].xyzw = float4(uVec, 0);
	mat[2].xyzw = float4(fVec, 0);
	mat[3].xyzw = float4(pos, 1);
*/

	return mat;
}

float4x4 TransformFromLookAtRibbon(float3 fwdDir, float3 upDir, float3 pos, bool preserveFwd)
{
	//Vector fVec = SafeNormalize(fwdDir, kUnitYAxis);
	float3 fVec = fwdDir;

	//Vector uVec = SafeNormalize(upDir, kUnitZAxis);
	float3 uVec = upDir;

	float3 kUnitXAxis = { 1.0f, 0.0f, 0.0f };
	float3 kUnitYAxis = { 0.0f, 1.0f, 0.0f };

	bool parallel = abs(dot(fVec, kUnitXAxis)) >= 0.999f;
	float3 xAxis = !parallel ? kUnitXAxis : kUnitYAxis;

	//Vector rVec = SafeNormalize(Cross(uVec, fVec), xAxis);
	float3 rVec = normalize(cross(uVec, fVec));

	//uVec = preserveFwd ? normalize(cross(fVec, rVec)) : uVec;
	//fVec = preserveFwd ? fVec : normalize(cross(rVec, uVec));

	// preserve z
	//uVec = normalize(cross(fVec, rVec));

	// preserve Y = upDIr = toNext for ribbons
	fVec = normalize(cross(rVec, uVec));
	
	//Mat44 mat(rVec.GetVec4(), uVec.GetVec4(), fVec.GetVec4(), pos.GetVec4());
	
	float4x4 mat;

	mat[0].xyzw = float4(rVec, 0);
	mat[1].xyzw = float4(uVec, 0);
	mat[2].xyzw = float4(fVec, 0);
	mat[3].xyzw = float4(pos, 1);

	return mat;
}

float4x4 TransformFromLookAtXUp(float3 fwdDir, float3 upDir, float3 pos, bool preserveFwd)
{
	float4x4 yUpMat = TransformFromLookAt(fwdDir, upDir, pos, preserveFwd);
	
	float4x4 mat = yUpMat;

	// up = x
	// x = -up
	mat[0].xyz = -yUpMat[1].xyz;
	mat[1].xyz = yUpMat[0].xyz;
	
	return mat;
}
float4x4 TransformFromLookAtYFw(float3 fwdDir, float3 upDir, float3 pos, bool preserveFwd)
{
	float4x4 yUpMat = TransformFromLookAt(fwdDir, upDir, pos, preserveFwd);
	
	float4x4 mat = yUpMat;

	// up = x
	// x = x
	mat[0].xyz = -yUpMat[1].xyz;
	mat[1].xyz = yUpMat[2].xyz;
	mat[2].xyz = yUpMat[0].xyz;
	
	return mat;
}


float SimpleCross(float2 v0, float2 v1)
{
	return v0.x * v1.y - v0.y * v1.x;
}

float4 FindBarycentric(float4 p0, float4 p1, float4 p2, float2 p)
{
	//float2 p1mp2 = p1.xy - p0.xy;

	float area = SimpleCross(p1.xy - p0.xy, p2.xy - p0.xy) / 2; //  cross(float3(p1.xy - p0.xy, 0), float3(p2.xy - p0.xy, 0)).z / 2;

	float p0Area = SimpleCross(p - p2.xy, p1.xy - p2.xy) / 2;  // cross(float3(p - p2.xy, 0), float3(p1.xy - p2.xy, 0)).z / 2;
	float p1Area = SimpleCross(p - p0.xy, p2.xy - p0.xy) / 2; //cross(float3(p - p0.xy, 0), float3(p2.xy - p0.xy, 0)).z / 2;

	float p2Area = SimpleCross(p - p1.xy, p0.xy - p1.xy) / 2;

	float p0Coord = p0Area / area;
	float p1Coord = p1Area / area;
	//float p2Coord = 1.0 - p0Coord - p1Coord;
	float p2Coord = p2Area / area;

	return float4(p0Coord, p1Coord, p2Coord, area);
}


float GetRandom(uint gameTicks, uint dispatchId, uint order)
{
	const uint primes[8] = { 16001, 6379, 17923, 7507, 19861, 7717, 22573, 9319 }; // , 24413, 11239, 25261, 12791
	
	float rand = (((( (dispatchId + 12345) * gameTicks)* primes[((order^dispatchId) + gameTicks) % 8])) & 0x0000FFFF) / float(0x0000FFFF);

	return rand;
}

float4x4 getRotateX( float angle)
{
	float cs = cos(angle);
	float sn = sin(angle);
	float4x4 rot;
	rot[0] = float4(1,0,0,0);
	rot[1] = float4(0, cs, sn, 0);
	rot[2] = float4(0, -sn, cs, 0);
	rot[3] = float4(0,0,0,1);
	return rot;
}

float4x4 getRotateY( float angle)
{
	float cs = cos(angle);
	float sn = sin(angle);
	float4x4 rot;
	rot[0] = float4(cs,0,-sn,0);
	rot[1] = float4(0, 1, 0, 0);
	rot[2] = float4(sn, 0, cs, 0);
	rot[3] = float4(0,0,0,1);
	return rot;
}

float4x4 getRotateZ( float angle)
{
	float cs = cos(angle);
	float sn = sin(angle);
	float4x4 rot;
	rot[0] = float4(cs,sn,0,0);
	rot[1] = float4(-sn, cs, 0, 0);
	rot[2] = float4(0, 0, 1, 0);
	rot[3] = float4(0,0,0,1);
	return rot;
}

float4x4 getMatrixFromAngles(float3 angles)
{
	return mul(getRotateZ(angles.z), mul(getRotateY(angles.y), getRotateX(angles.x)));
}

float LinStep(const float a, const float b, const float f)
{
	return saturate((f-a) / (b-a));
}


Texture3D<float4> Tex2DAs3D(Texture2D<float4> inTex)
{
	uint4 tlo = __get_tsharplo(inTex);
	uint4 thi = __get_tsharphi(inTex);
	
	return __create_texture<Texture3D<float4> >(tlo, thi);
}

struct DepthPosInfo
{
	float4 posH;
	float3 posNDC;
	uint2  posSS;
	float  rawDepth;
	float  screenDepth;
	float  depthDiff;
	float3 depthPosNDC;
	float4 depthPosH;
	float3 depthPosWS;

	float2 motionVectorSNormFloat;
	int2 motionVectorSSInt;
	float2 motionVectorSSFloat;
	int2 lastFrameSSpos;
	float3 depthPosNDCUnJittered;
	float3 depthPosNDCLastFrameUnjittered;
	float3 depthPosNDCLastFrame;
	float3 depthPosWsLastFrame;

};

DepthPosInfo DPISetup(float3 positionWS, ParticleComputeJobSrt *pSrt)
{
	DepthPosInfo info = DepthPosInfo(0);
	info.posH = mul(float4(positionWS, 1), pSrt->m_pPassDataSrt->g_mVP);
	info.posNDC = info.posH.xyz / info.posH.w;
	info.posSS = uint2(floor(float2((info.posNDC.x / 2.0f + 0.5f) * pSrt->m_screenResolution.x, 
						(1.0f - (info.posNDC.y / 2.0f + 0.5f)) * pSrt->m_screenResolution.y)));
	return info;
}

void DPISampleDepth(inout DepthPosInfo info, ParticleComputeJobSrt *pSrt, bool usePrevFrame)
{	
	info.rawDepth = pSrt->m_pPassDataSrt->m_opaquePlusAlphaDepthTexture[info.posSS];
	info.screenDepth = GetLinearDepth(info.rawDepth, pSrt->m_depthParams);
	info.depthDiff = info.posH.w - info.screenDepth;
}

void DPISampleDepthPrev(inout DepthPosInfo info, ParticleComputeJobSrt *pSrt, bool usePrevFrame)
{	
	info.rawDepth = pSrt->m_pPassDataSrt->m_lastFrameOpaquePlusAlphaDepthTexture[info.posSS];
	info.screenDepth = GetLinearDepth(info.rawDepth, pSrt->m_depthParams);
	info.depthDiff = info.posH.w - info.screenDepth;
}

void DPIGetDepthPos(inout DepthPosInfo info,  ParticleComputeJobSrt *pSrt)
{
	info.depthPosNDC = float3( info.posNDC.xy, info.rawDepth);
	info.depthPosH = mul(float4(info.depthPosNDC, 1.0), pSrt->m_pPassDataSrt->m_mAltVPInv);
	info.depthPosWS = info.depthPosH.xyz / info.depthPosH.w;
	info.depthPosWS += pSrt->m_altWorldOrigin;
}

void DPIProjectLastFrame(inout DepthPosInfo info,  ParticleComputeJobSrt *pSrt)
{
	info.motionVectorSNormFloat = pSrt->m_pPassDataSrt->m_motionVector[info.posSS];
	info.motionVectorSSInt = int2(info.motionVectorSNormFloat * pSrt->m_screenResolution);
	info.motionVectorSSFloat = (info.motionVectorSNormFloat * pSrt->m_screenResolution);
	info.lastFrameSSpos = int2(float2(info.posSS) + info.motionVectorSSFloat);

	info.depthPosNDCUnJittered = info.depthPosNDC;
	info.depthPosNDCUnJittered.xy -= pSrt->m_projectionJitterOffsets.xy;

	info.depthPosNDCLastFrameUnjittered = float3(
		info.depthPosNDCUnJittered.x + info.motionVectorSNormFloat.x * 2,
		info.depthPosNDCUnJittered.y - info.motionVectorSNormFloat.y * 2,
		pSrt->m_pPassDataSrt->m_lastFrameOpaquePlusAlphaDepthTexture[info.lastFrameSSpos]);
	info.depthPosNDCLastFrame = 	info.depthPosNDCLastFrameUnjittered;
	info.depthPosNDCLastFrameUnjittered.xy += pSrt->m_projectionJitterOffsets.zw;

	float4 posLastFramePosH = mul(float4(info.depthPosNDCLastFrame /*finalPosLastFramePosNdc*/, 1), pSrt->m_pPassDataSrt->m_mLastFrameAltVPInv);
	info.depthPosWsLastFrame = posLastFramePosH.xyz / posLastFramePosH.w;
	info.depthPosWsLastFrame += pSrt->m_lastFrameAltWorldOrigin;
}

float3 SafeNormalize(float3 vec)
{
	return normalize(vec + kEpsilon);
}

#define ENABLE_FEEDBACK_DEBUG 0

void DebugCross(RWStructuredBuffer<ParticleFeedBackHeaderData> particleFeedBackHeaderData, RWStructuredBuffer<ParticleFeedBackData> particleFeedBackData, float3 pos, float r, float4 c)
{
#if ENABLE_FEEDBACK_DEBUG
	uint4 vsharp = __get_vsharp(particleFeedBackHeaderData);
		
	uint prevIndex = __buffer_atomic_add(1, uint2(0, 0), vsharp, 0, 0);
	if (prevIndex < kMaxFeedBackEvents)
	{
		// can add new data
		particleFeedBackData[prevIndex].m_data0 = uint4(kFeedBackTypeDebugCross, 0, 0, 0);
		particleFeedBackData[prevIndex].m_data1 = float4(pos, r);
		particleFeedBackData[prevIndex].m_data2 = float4(c);
		particleFeedBackData[prevIndex].m_data3 = float4(0.0f, 0.0f, 0.0f, 0.0f);
	}
#endif
}

void DebugProbeResult(RWStructuredBuffer<ParticleFeedBackHeaderData> particleFeedBackHeaderData, RWStructuredBuffer<ParticleFeedBackData> particleFeedBackData, float3 pos, float3 rgb, float weightSum, uint frame)
{
#if ENABLE_FEEDBACK_DEBUG
	uint4 vsharp = __get_vsharp(particleFeedBackHeaderData);
		
	uint prevIndex = __buffer_atomic_add(1, uint2(0, 0), vsharp, 0, 0);
	if (prevIndex < kMaxFeedBackEvents)
	{
		// can add new data
		particleFeedBackData[prevIndex].m_data0 = uint4(kFeedBackTypeDebugProbeResult, frame, 0, 0);
		particleFeedBackData[prevIndex].m_data1 = float4(pos, weightSum);
		particleFeedBackData[prevIndex].m_data2 = float4(rgb, 0);
		particleFeedBackData[prevIndex].m_data3 = float4(0.0f, 0.0f, 0.0f, 0.0f);
	}
#endif
}
void DebugProbeState(RWStructuredBuffer<ParticleFeedBackHeaderData> particleFeedBackHeaderData, RWStructuredBuffer<ParticleFeedBackData> particleFeedBackData, float3 pos, float r, float3 c, float weight)
{
#if ENABLE_FEEDBACK_DEBUG
	uint4 vsharp = __get_vsharp(particleFeedBackHeaderData);
		
	uint prevIndex = __buffer_atomic_add(1, uint2(0, 0), vsharp, 0, 0);
	if (prevIndex < kMaxFeedBackEvents)
	{
		// can add new data
		particleFeedBackData[prevIndex].m_data0 = uint4(kFeedBackTypeDebugProbeState, 0, 0, 0);
		particleFeedBackData[prevIndex].m_data1 = float4(pos, r);
		particleFeedBackData[prevIndex].m_data2 = float4(c, weight);
		particleFeedBackData[prevIndex].m_data3 = float4(0.0f, 0.0f, 0.0f, 0.0f);
	}
#endif
}

void DebugProbeStateScalar(RWStructuredBuffer<ParticleFeedBackHeaderData> particleFeedBackHeaderData, RWStructuredBuffer<ParticleFeedBackData> particleFeedBackData, float3 pos, float r, float3 c, float weight)
{
#if ENABLE_FEEDBACK_DEBUG
	uint4 vsharp = __get_vsharp(particleFeedBackHeaderData);
		
	uint prevIndex = __buffer_atomic_add(1, uint2(0, 0), vsharp, 0, 0);
	if (prevIndex < kMaxFeedBackEvents)
	{
		// can add new data
		particleFeedBackData[prevIndex].m_data0 = uint4(kFeedBackTypeDebugProbeState, 1, 0, 0);
		particleFeedBackData[prevIndex].m_data1 = float4(pos, r);
		particleFeedBackData[prevIndex].m_data2 = float4(c, weight);
		particleFeedBackData[prevIndex].m_data3 = float4(0.0f, 0.0f, 0.0f, 0.0f);
	}
#endif
}


void DebugProbeStateFailedOcclusionScalar(RWStructuredBuffer<ParticleFeedBackHeaderData> particleFeedBackHeaderData, RWStructuredBuffer<ParticleFeedBackData> particleFeedBackData, 
float3 pos, float depth, float testDepth, float3 targetPos, float3 c)
{
#if ENABLE_FEEDBACK_DEBUG
	uint4 vsharp = __get_vsharp(particleFeedBackHeaderData);
		
	uint prevIndex = __buffer_atomic_add(1, uint2(0, 0), vsharp, 0, 0);
	if (prevIndex < kMaxFeedBackEvents)
	{
		// can add new data
		particleFeedBackData[prevIndex].m_data0 = uint4(kFeedBackTypeDebugProbeOcclusionFail, 1, 0, 0);
		particleFeedBackData[prevIndex].m_data1 = float4(pos, 0);
		particleFeedBackData[prevIndex].m_data2 = float4(c, testDepth);
		particleFeedBackData[prevIndex].m_data3 = float4(targetPos, depth);
	}
#endif
}


void DebugProbeColorVariance(RWStructuredBuffer<ParticleFeedBackHeaderData> particleFeedBackHeaderData, RWStructuredBuffer<ParticleFeedBackData> particleFeedBackData, float3 pos,
float variance, float mean, float maxIntesnity, float resultIntensity, float3 finalColor)
{
#if ENABLE_FEEDBACK_DEBUG
	uint4 vsharp = __get_vsharp(particleFeedBackHeaderData);
		
	uint prevIndex = __buffer_atomic_add(1, uint2(0, 0), vsharp, 0, 0);
	if (prevIndex < kMaxFeedBackEvents)
	{
		// can add new data
		particleFeedBackData[prevIndex].m_data0 = uint4(kFeedBackTypeDebugProbeColorVaraince, 0, 0, 0);
		particleFeedBackData[prevIndex].m_data1 = float4(pos, 0);
		particleFeedBackData[prevIndex].m_data2 = float4(variance, mean, maxIntesnity, resultIntensity);
		particleFeedBackData[prevIndex].m_data3 = float4(finalColor, 0);
	}
#endif
}


void DebugProbeDepthVariance(RWStructuredBuffer<ParticleFeedBackHeaderData> particleFeedBackHeaderData, RWStructuredBuffer<ParticleFeedBackData> particleFeedBackData, float3 pos,
float2 variance, float3 meanPos, float3 varianceVec, float probabilityOfGeoBehindProbe)
{
#if ENABLE_FEEDBACK_DEBUG
	uint4 vsharp = __get_vsharp(particleFeedBackHeaderData);
		
	uint prevIndex = __buffer_atomic_add(1, uint2(0, 0), vsharp, 0, 0);
	if (prevIndex < kMaxFeedBackEvents)
	{
		// can add new data
		particleFeedBackData[prevIndex].m_data0 = uint4(kFeedBackTypeDebugProbeDepthVaraince, 0, 0, 0);
		particleFeedBackData[prevIndex].m_data1 = float4(pos, varianceVec.x);
		particleFeedBackData[prevIndex].m_data2 = float4(variance, varianceVec.yz);
		particleFeedBackData[prevIndex].m_data3 = float4(meanPos, probabilityOfGeoBehindProbe);
	}
#endif
}



void DebugProbeDepthVarianceNew(RWStructuredBuffer<ParticleFeedBackHeaderData> particleFeedBackHeaderData, RWStructuredBuffer<ParticleFeedBackData> particleFeedBackData, float3 pos,
float3 projPos, float2 variance, float froxelProbabilityOfGeoBehindProbe) //, float3 meanPos, float3 varianceVec, float probabilityOfGeoBehindProbe)
{
#if ENABLE_FEEDBACK_DEBUG
	uint4 vsharp = __get_vsharp(particleFeedBackHeaderData);
		
	uint prevIndex = __buffer_atomic_add(1, uint2(0, 0), vsharp, 0, 0);
	if (prevIndex < kMaxFeedBackEvents)
	{
		// can add new data
		particleFeedBackData[prevIndex].m_data0 = uint4(kFeedBackTypeDebugProbeDepthVarainceNew, 0, 0, 0);
		particleFeedBackData[prevIndex].m_data1 = float4(pos, froxelProbabilityOfGeoBehindProbe);
		particleFeedBackData[prevIndex].m_data2 = float4(variance, 0, 0);
		particleFeedBackData[prevIndex].m_data3 = float4(projPos, 0);
	}
#endif
}


void DebugProbeData(RWStructuredBuffer<ParticleFeedBackHeaderData> particleFeedBackHeaderData, RWStructuredBuffer<ParticleFeedBackData> particleFeedBackData, float3 pos, float r, float4 c, float planeDist, uint splitAxis, float splitPos, float positionLS)
{
#if ENABLE_FEEDBACK_DEBUG
	uint4 vsharp = __get_vsharp(particleFeedBackHeaderData);
		
	uint prevIndex = __buffer_atomic_add(1, uint2(0, 0), vsharp, 0, 0);
	if (prevIndex < kMaxFeedBackEvents)
	{
		// can add new data
		particleFeedBackData[prevIndex].m_data0 = uint4(kFeedBackTypeDebugProbeData, splitAxis, 0, 0);
		particleFeedBackData[prevIndex].m_data1 = float4(pos, r);
		particleFeedBackData[prevIndex].m_data2 = float4(c);
		particleFeedBackData[prevIndex].m_data3 = float4(planeDist, splitPos, positionLS, 0.0f);
	}
#endif
}
void DebugProbeFroxel(RWStructuredBuffer<ParticleFeedBackHeaderData> particleFeedBackHeaderData, RWStructuredBuffer<ParticleFeedBackData> particleFeedBackData, float3 pos, float3 samplingPos, float r, float bigR, float4 c)
{
#if ENABLE_FEEDBACK_DEBUG
	uint4 vsharp = __get_vsharp(particleFeedBackHeaderData);
		
	uint prevIndex = __buffer_atomic_add(1, uint2(0, 0), vsharp, 0, 0);
	if (prevIndex < kMaxFeedBackEvents)
	{
		// can add new data
		particleFeedBackData[prevIndex].m_data0 = uint4(kFeedBackTypeDebugProbeFroxel, 0, 0, 0);
		particleFeedBackData[prevIndex].m_data1 = float4(pos, r);
		particleFeedBackData[prevIndex].m_data2 = float4(c);
		particleFeedBackData[prevIndex].m_data3 = float4(samplingPos, bigR);
	}
#endif
}
void DebugProbeFroxelBox(RWStructuredBuffer<ParticleFeedBackHeaderData> particleFeedBackHeaderData, RWStructuredBuffer<ParticleFeedBackData> particleFeedBackData, float3 pos0, float3 pos1, float3 pos2, float3 pos3)
{
#if ENABLE_FEEDBACK_DEBUG
	uint4 vsharp = __get_vsharp(particleFeedBackHeaderData);
		
	uint prevIndex = __buffer_atomic_add(1, uint2(0, 0), vsharp, 0, 0);
	if (prevIndex < kMaxFeedBackEvents)
	{
		// can add new data
		particleFeedBackData[prevIndex].m_data0 = uint4(kFeedBackTypeDebugProbeFroxelBox, 0, 0, 0);
		particleFeedBackData[prevIndex].m_data1 = float4(pos0, pos3.x);
		particleFeedBackData[prevIndex].m_data2 = float4(pos1, pos3.y);
		particleFeedBackData[prevIndex].m_data3 = float4(pos2, pos3.z);
	}
#endif
}

void SpawnSoundBasedOnOllision(RWStructuredBuffer<ParticleFeedBackHeaderData> particleFeedBackHeaderData, RWStructuredBuffer<ParticleFeedBackData> particleFeedBackData,
	float3 pos, float3 vel, float yAcc, float lifespan, float gameTime)
{
	uint4 vsharp = __get_vsharp(particleFeedBackHeaderData);
		
	uint prevIndex = __buffer_atomic_add(1, uint2(0, 0), vsharp, 0, 0);
	if (prevIndex < kMaxFeedBackEvents)
	{
		// can add new data
		particleFeedBackData[prevIndex].m_data0 = uint4(kFeedBackTypeSoundSpawnWithRay, 0, 0, 0);
		particleFeedBackData[prevIndex].m_data1 = float4(pos, lifespan);
		particleFeedBackData[prevIndex].m_data2 = float4(vel, yAcc);
		particleFeedBackData[prevIndex].m_data3 = float4(gameTime, 0, 0, 0);
	}
}


void SetSplashSpawnedOnPlayer(RWStructuredBuffer<ParticleFeedBackHeaderData> particleFeedBackHeaderData, float rate)
{
	uint4 vsharp = __get_vsharp(particleFeedBackHeaderData);
	
	__buffer_atomic_add(1, uint2(0, 0), vsharp, 4, 0);

	//particleFeedBackHeaderData[0].m_data0[0] = 1.0; // no need to atomically increment or anything like that, since we just care about whether it ever happened
}

float3 ScreenPosToNdc(ParticleComputeJobSrt *pSrt, uint2 sspos, float ndcDepth)
{
	float3 posNdc = float3((sspos.x + 0.5) / pSrt->m_screenResolution.x * 2 - 1, -((sspos.y + 0.5) / pSrt->m_screenResolution.y * 2 - 1), ndcDepth);

	return posNdc;
}

float3 CalculateDepthNormal(ParticleComputeJobSrt *pSrt, uint2 sspos, bool useOpaquePlusAlphaDepth)
{
	uint2 ssposX = sspos + uint2(1, 0);
	uint2 ssposY = sspos + uint2(0, 1);
	
	Texture2D<float> depthBufferToUse = useOpaquePlusAlphaDepth ? pSrt->m_pPassDataSrt->m_opaquePlusAlphaDepthTexture : pSrt->m_pPassDataSrt->m_primaryDepthTexture;

	float3 posWs;
	{
		float3 posNdcNew = ScreenPosToNdc(pSrt, sspos, depthBufferToUse[sspos]);
		float4 posHNew = mul(float4(posNdcNew, 1), pSrt->m_pPassDataSrt->m_mAltVPInv);
		float3 posWsNew = posHNew.xyz / posHNew.w;
		posWs = posWsNew;
	}

	float3 posWsX;
	{
		float3 posNdcNew = ScreenPosToNdc(pSrt, ssposX, depthBufferToUse[ssposX]);
		float4 posHNew = mul(float4(posNdcNew, 1), pSrt->m_pPassDataSrt->m_mAltVPInv);
		float3 posWsNew = posHNew.xyz / posHNew.w;
		posWsX = posWsNew;
	}

	float3 posWsY;
	{
		float3 posNdcNew = ScreenPosToNdc(pSrt, ssposY, depthBufferToUse[ssposY]);
		float4 posHNew = mul(float4(posNdcNew, 1), pSrt->m_pPassDataSrt->m_mAltVPInv);
		float3 posWsNew = posHNew.xyz / posHNew.w;
		posWsY = posWsNew;
	}

	float3 v0 = (posWsX - posWs);
	float3 v1 = (posWsY - posWs);

	float3 n = normalize(-cross(v0, v1));

	return n;
}


struct SamplingResultEntry
{
	float m_results[64];
};


struct Dc_PartSamplingUvs
{
	float2 m_floats[64/2];
	uint m_floatCount;
};


struct ParticleRTSamplingSrt
{
	Texture2D<float>		m_textures[128];
	StructuredBuffer<Dc_PartSamplingUvs>	m_samplingProfiles[128];
	StructuredBuffer<uint>	m_resultIndices;
	RWStructuredBuffer<SamplingResultEntry>	m_results;

	SamplerState m_linearSampler;
	
	uint m_numTextures;
};

#endif

