/*
* Copyright (c) 2014 Naughty Dog, Inc.
* A Wholly Owned Subsidiary of Sony Computer Entertainment, Inc.
* Use and distribution without consent strictly prohibited
*/



float4 EvaluatePixelShader(Particle2D p, int iPart, int iPixel, uint2 rayPos, float4 color, ParticleRayTraceSrt *pSrt)
{
	/*
	float u = (dot((rayPos - p.m_pos), p.m_x) / p.m_size) / 2.0f + 1.0f;
	float v = (dot((rayPos - p.m_pos), float2(-p.m_x.y, p.m_x.x)) / p.m_size) / 2.0f + 1.0f;

	if (abs(u) >= 0 && abs(u) < 1 && abs(v) >= 0 && abs(v) < 1)
	return float4(u / 4.0f, v / 4.0f, 0.0f, 1.0f);
	else
	return float4(0, 0, 0.0f, 0);
	*/

	float u = dot((rayPos - p.m_pos), p.m_x);
	float v = dot((rayPos - p.m_pos), float2(-p.m_x.y, p.m_x.x));

	if (abs(u) < p.m_size && abs(v) < p.m_size)
	{
		u = u / p.m_size;
		v = v / p.m_size;

		u = u / 2.0f + 0.5f;
		v = v / 2.0f + 0.5f;

		int mipLevel = pSrt->m_mipLevel;
		uint2 texDim;

		pSrt->m_spriteTexture.GetDimensions(texDim.x, texDim.y);

		int dynamicMipLevel = 0;

		int ratio = texDim.x  * pSrt->m_resolution / (p.m_size * 2);

		if (ratio >= 0x00000200)
		{
			dynamicMipLevel = 8;
		}
		else if (ratio & 0x00000100)
		{
			dynamicMipLevel = 7;
		}
		else if (ratio & 0x00000080)
		{
			dynamicMipLevel = 6;
		}
		else if (ratio & 0x00000040)
		{
			dynamicMipLevel = 5;
		}
		else if (ratio & 0x00000020)
		{
			dynamicMipLevel = 4;
		}
		else if (ratio & 0x00000010)
		{
			dynamicMipLevel = 3;
		}
		else if (ratio & 0x00000008)
		{
			dynamicMipLevel = 2;
		}
		else if (ratio & 0x00000004)
		{
			dynamicMipLevel = 1;
		}
		else if (ratio & 0x00000002)
		{
			dynamicMipLevel = 0;
		}
		else
			dynamicMipLevel = 0;


		if (mipLevel > -1)
			dynamicMipLevel = mipLevel;

		float3 srcColor = pSrt->m_spriteTexture.SampleLevel(pSrt->m_linearSampler, float2(u, v), dynamicMipLevel).rgb * color.rgb;
			//float3 srcColor = float3(1.0f, 1.0f, 1.0f) * color.rgb + pSrt->m_dummySrt.m_pSrt->m_textures[int(color.x * 100)].SampleLevel(pSrt->m_linearSampler, float2(u, v), dynamicMipLevel).rgb;



			float srcAlpha = pSrt->m_spriteAlpha.SampleLevel(pSrt->m_linearSampler, float2(u, v), dynamicMipLevel).x * color.a;
		//pSrt->m_destTexture[rayPos] = float4(0.0f, 1.0f, 0.0f, 1.0f);

		if (pSrt->m_flags & FLAG_USE_TEXTURE)
		{
			return float4(srcColor, srcAlpha);
		}
		else if (pSrt->m_flags & FLAG_SHOW_MIP)
		{
			if (dynamicMipLevel == 0)
				return float4(1.0, 1.0f, 1.0f, 1.0f);
			else if (dynamicMipLevel == 1)
				return float4(1.0, 1.0f, 0.0f, 1.0f);
			else if (dynamicMipLevel == 2)
				return float4(0.0, 0.0f, 1.0f, 1.0f);
			else if (dynamicMipLevel == 3)
				return float4(0.0, 1.0f, 0.0f, 1.0f);
			else if (dynamicMipLevel == 4)
				return float4(0.0, 1.0f, 0.0f, 1.0f);
			else
				return float4(1.0, 0.0f, 1.0f, 1.0f);
		}
		else
		{
			return float4(u, v, 0.0f, 1.0f);
		}
	}
	else
	{
		return float4(0);
	}
}




float4 EvaluatePixelShaderUV(int iPart, int iPixel, float2 uv, float4 color, uint flags, SamplerState linearSampler, Texture2D<float4> spriteAlpha)
{
	/*
	float u = (dot((rayPos - p.m_pos), p.m_x) / p.m_size) / 2.0f + 1.0f;
	float v = (dot((rayPos - p.m_pos), float2(-p.m_x.y, p.m_x.x)) / p.m_size) / 2.0f + 1.0f;

	if (abs(u) >= 0 && abs(u) < 1 && abs(v) >= 0 && abs(v) < 1)
	return float4(u / 4.0f, v / 4.0f, 0.0f, 1.0f);
	else
	return float4(0, 0, 0.0f, 0);
	*/


	//if (abs(u) < p.m_size && abs(v) < p.m_size)

	//u = u / p.m_size;
	//v = v / p.m_size;

	//u = u / 2.0f + 0.5f;
	//	v = v / 2.0f + 0.5f;


	int dynamicMipLevel = 0;

	//float3 srcColor = pSrt->m_spriteTexture.SampleLevel(pSrt->m_linearSampler, float2(u, v), dynamicMipLevel).rgb * color.rgb;
	
	// correct
	//float srcAlpha = pSrt->m_spriteAlpha.SampleGrad(linearSampler, uv, uvDdx, uvDdy).x;

	uint4 tsharplo = __get_tsharplo(spriteAlpha);
	uint4 ssharp = __get_ssharp(linearSampler);

	uint opts = __kImage_RO | __kImage_texture2d | __kImage_R128 ;
	//uv = float2(0.0, 0.0);
	
	image_load_result_t result = __image_sample(float4(uv, 0, 0), tsharplo, 0, ssharp, opts);
	//float texAlpha = bit_cast<float>(result.data);
	//float srcAlpha = pSrt->m_spriteAlpha.SampleGrad(linearSampler, uv, uvDdx, uvDdy).x;
	float texAlpha = spriteAlpha.SampleLevel(linearSampler, uv, 0).x;
	
	float srcAlpha = texAlpha;// * color.a;
	float3 srcColor =  color.rgb;
	
	//float3 srcColor =  color.rgb;
	//srcColor.x = texAlpha * color.a;
	//float3 srcColor = float3(1,1,1);
	//float srcAlpha = color.a;

	//srcAlpha = pow(srcAlpha, 0.4545);
	//srcAlpha *= pow(color.a, 0.4545);

#if USE_DEBUG_CHECKS
	if (flags & FLAG_ALPHA_ZERO_EARLY_DISCARD)
#endif
	{
		//if (srcAlpha < 0.005)
		//	return float4(0.0f, 0.0f, 0.0f, 0.0f);
	}

	//if we have just alpha texture
	
		// else if we have color texture too
		//float3 srcColor = pSrt->m_spriteTexture.SampleLevel(linearSampler, uv, dynamicMipLevel).rgb * color.rgb;

		//float3 srcTexColor = pSrt->m_dummySrt.m_pSrt->m_textures[iPart % 8].SampleLevel(linearSampler, uv, dynamicMipLevel).rgb;
		srcColor = srcColor;// + srcTexColor;

	//pSrt->m_destTexture[rayPos] = float4(0.0f, 1.0f, 0.0f, 1.0f);
#if USE_DEBUG_CHECKS

	if (flags & FLAG_RENDER_STATS)
	{
		return float4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, srcAlpha);
	}
	else if (flags & FLAG_USE_TEXTURE)
	{
#endif
		return float4(srcColor, srcAlpha);

#if USE_DEBUG_CHECKS
	}
	else if (flags & FLAG_SHOW_MIP)
	{
		if (dynamicMipLevel == 0)
			return float4(1.0, 1.0f, 1.0f, 1.0f);
		else if (dynamicMipLevel == 1)
			return float4(1.0, 1.0f, 0.0f, 1.0f);
		else if (dynamicMipLevel == 2)
			return float4(0.0, 0.0f, 1.0f, 1.0f);
		else if (dynamicMipLevel == 3)
			return float4(0.0, 1.0f, 0.0f, 1.0f);
		else if (dynamicMipLevel == 4)
			return float4(0.0, 1.0f, 0.0f, 1.0f);
		else
			return float4(1.0, 0.0f, 1.0f, 1.0f);
	}
	else
	{
		return float4(uv.x, uv.y, 0.0f, 1.0f);
	}
#endif

}
