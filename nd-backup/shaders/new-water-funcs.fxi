// Shared structures for water
//#pragma warning (disable:7203)
//#pragma warning (default:7203)

// Same as quadtree-mgr.h
#define kMaxNumBoxes 700

// These are for dynamic use in (m_useFlags). Should match the enum in quadtree-mgr.h :QuadTreeConstantInfo
#define kUseUVDistortionTexture   0x0001
#define kUseFlow                  0x0002
#define kUseHeightmap             0x0004
#define kUseDeformation           0x0008
#define kUseWaveChannel           0x0010
#define kUseAlphaMask             0x0020
#define kUseRipples               0x0040
#define	kUseFrequencyMask         0x0080
#define kUseHeightmapNormal       0x0100

// These should match the enum in quadtree-mgr.h :QuadTreeConstantInfo
#define	kShowShaded            0x00000000
#define	kShowNormals           0x00000001
#define	kShowNormalsFlat       0x00000002
#define	kShowFresnel           0x00000004
#define	kShowCheckerboard      0x00000008
#define	kShowFoam              0x00000010
#define	kShowSubsurface        0x00000020
#define	kShowStrain            0x00000040
#define	kShowLerpDistance      0x00000080
#define	kShowWPOffset          0x00000100
#define	kShowWPNormals         0x00000200
#define	kShowWPHeights         0x00000400
#define	kShowFlow              0x00000800
#define	kShowAmplitude         0x00001000
#define	kShowHeight            0x00002000
#define	kShowHeightNormal      0x00004000
#define	kShowAlpha             0x00008000
#define	kShowFrequencyRGB      0x00010000
#define	kShowFrequencyAlpha    0x00020000
#define	kShowTextureUV         0x00040000
#define	kShowDistortUV         0x00080000
#define	kShowDepthMasks        0x00100000
#define	kShowOcean             0x00200000
#define	kShowWireframe         0x10000000  // very last 

#define kOk             0x0000
#define kNotActive      0x0001
#define kNotFinite      0x0002
#define kTooLarge       0x0004
#define kFlowTooLarge   0x0008
#define kCulledOut      0x0010
#define kFailed         0x0100 // Ray failed to intersect water
#define kUnderwater     0x0200 // Ray started underwater
#define kBadData	    0x0400 // Failed because of external reasons
#define kNoResult       0x0000

#define kHasResult         0x0001 // Stop passes, we got a result.
#define kHasPartialResult  0x0002 // Continue to pass2

struct QuadBlockInfo 
{
	float4 m_pos;
	float4 m_lerp;
};

struct QuadBlockInstance 
{
	QuadBlockInfo m_info[kMaxNumBoxes]; // minX, minZ, size of block, lerp 
};


// output structure
// Same as in quadtree-mgr.h <QuadTreeVertex>
struct QuadTreeVertex
{
	float4 m_basePosition;
	float3 m_position;
	float3 m_positionPrev;
	float3 m_normal; 
	float4 m_color0; //flow xy, foam, subsurface
	float4 m_color1; // flow amplitude, alpha, height, blend
	float4 m_freqMask; // alpha
	float3 m_flow; // flow (rgb), height
	float3 m_heightNormal;
	float  m_height;
};

struct WPDisplacement
{
	float3 m_disp;
	float  m_strain;
	float3 m_dx;
	float3 m_dz;
	float2 m_pad;
};

struct TexturesAndSamplers 
{
	StructuredBuffer<WPDisplacement>  m_wpGrid0;
	StructuredBuffer<WPDisplacement>  m_wpGrid1;
	StructuredBuffer<WPDisplacement>  m_wpGrid2;
	StructuredBuffer<WPDisplacement>  m_wpGrid3;

	StructuredBuffer<WPDisplacement>  m_wpGridPrev0;
	StructuredBuffer<WPDisplacement>  m_wpGridPrev1;
	StructuredBuffer<WPDisplacement>  m_wpGridPrev2;
	StructuredBuffer<WPDisplacement>  m_wpGridPrev3;

	// new stuff

	StructuredBuffer<uint4>				m_wpDataGrid0;
	StructuredBuffer<uint4>				m_wpDataGrid1;
	StructuredBuffer<uint4>				m_wpDataGrid2;
	StructuredBuffer<uint4>				m_wpDataGrid3;

	StructuredBuffer<uint4>				m_wpDataGridPrev0;
	StructuredBuffer<uint4>				m_wpDataGridPrev1;
	StructuredBuffer<uint4>				m_wpDataGridPrev2;
	StructuredBuffer<uint4>				m_wpDataGridPrev3;

	Texture2D<float4>  m_heightfieldTx;
	Texture2D<float4>  m_heightfieldNormalTx;
	Texture2D<float4>  m_flowTx;
	Texture2D<float4>  m_normalMapTx;
	Texture2D<float4>  m_boatMapTx;
	Texture2D<float4>  m_uvDistortionTx;
	Texture2D<float4>  m_alphaMaskTx;
	Texture2D<float3>  m_displacementTx; // range is remapped from (0...)->[-2..0..]. remember to renormalize with (dispTx-1)*2
	Texture2D<float3>  m_displacementNormalTx;
	Texture2D<float2>  m_foamChurnTx;
	Texture2D<float>   m_heightTx;
	Texture2D<float4>  m_ripplesTx;
	Texture2D<float4>  m_ripplesPlayerTx;
	Texture2D<float4>  m_frequencyMaskTx;

	SamplerState	   g_linearSampler;
	SamplerState	   g_linearClampSampler;

};

struct GridStructure 
{
	StructuredBuffer<uint4>  m_dataGrid0;
	StructuredBuffer<uint4>  m_dataGrid1;
	StructuredBuffer<uint4>  m_dataGrid2;
	StructuredBuffer<uint4>  m_dataGrid3;
	float4   m_octave;
};

struct QuadBlockConstantInfo
{
    int     m_active;
    int     m_shaderIndex;
    int     m_sideBlock;
    int     m_numBlocks;

    int     m_numVerticesPerBlock;
    float   m_time;
    uint    m_useFlags;
    uint    m_showFlags;


	// Parameters for quadtre (not Cs), but needed for parameter unification
    uint    m_renderPassMask;
    float   m_size;
    int     m_maxLevel;
    int     m_needsWP;

    int     m_wpSide;
    int     m_numLevels;
    float   m_startSize;
    uint    m_generateMotionVector;

    uint    m_animate;
    float   m_startDistance;
    float   m_octaveScale;
    float   m_extendY;

    float   m_extendXZ;
    float   m_offset;
    float   m_multY;
    float   m_uvScale;

	float   m_frequencyInLerp; // lerp IN frequencies by distance
	uint    m_failQueries;   // fail ALL queries
	uint    m_pad002;
	uint    m_pad003;

    float4  m_wpFrequency;
    float4  m_wpFrequencyBlend;
    float4  m_wpScaleX;
    float4  m_wpScaleZ;
    float4  m_wpScaleXBlend;
    float4  m_wpScaleZBlend;

    float4  m_wpDispY;
    float4  m_wpDispXZ;
    float4  m_wpScrollX;
    float4  m_wpScrollZ;
    float4  m_wpScrollXBlend;
    float4  m_wpScrollZBlend;

    float4  m_wpPositionX;
    float4  m_wpPositionZ;

    float4  m_wpDispNormal;
	float4  m_wpLerpInStartDistance;
	float4  m_wpLerpInEndDistance;
    float4  m_wpLerpOutDistance;
	
    float4  m_wpFoamStart;
    float4  m_wpFoamEnd;
    float4  m_wpSubsurfaceStart;
    float4  m_wpSubsurfaceEnd;
	float4  m_wpFrequencyOffset;
	float4  m_wpFrequencyIn;
	float4  m_wpStrain;

	float   m_foamBias;
	float   m_foamOffset;
	float   m_subsurfaceBias;
	float   m_subsurfaceOffset;

    float   m_minDistance;
    float   m_octaveScale2;
    float   m_octaveBlend;
    float   m_octaveBlend2;

    float   m_flowInterval;
    float   m_flowMagnitude;
    int     m_use2dLod;
    uint    pad003; // numBoxesCompactedList

    uint    m_numClippingPlanes;
    float   m_deformationMag;
    float   m_waveChannelMag;
    float   m_terrainMag;

    float   m_blendValue;
    int     m_blendIndex; // for wave particle
    int     m_cameraTeleportedThisFrame;
    float   m_quadSize;

    float4  m_octave;
    float4  m_center;
    float4  m_altWorldOrigin;
    float4  m_altWorldOriginLastFrame;

    float4x4  m_mAltWorldToScreen;
    float4x4  m_mAltWorldToScreenLastFrame;
    float4    m_projectionJitterOffsets;
	float4  m_waterPropertiesScaleOffset;
	float4 	m_waterPropertiesDelta;
	float4  m_freqCenter;
	
    float4  m_waveChannelX;
    float4  m_waveChannelZ;
    float4  m_waveChannelMagZ;
    float4  m_deformationPosScale;
    float4  m_clippingPlane[4];     // up to 4 clipping planes
    float4  m_flowStrength;

    float4  m_camera;
    float4  m_cameraPrev;
    float4  m_oceanColor;
    float4  m_skyColor;
    float4  m_sunDirection;

    int     m_hasBbox;
    int     m_invertClippingPlanes;
	float   m_rippleDisplacementScale;
	float   m_ripplePinchScale;

	float   m_rippleFoamRate;
	float   m_strainBias;
	
	float   m_uvDistortionScale;
	float   m_amplitudeOffset;

    float4  m_ripples;
    float4  m_ripplesPlayer;
    float4  m_bboxMin;
    float4  m_bboxMax;
    float4  m_screenSizeParam;

    float   m_delta;
    float   m_decayRate;
    int     m_useWaterProperties;
    float   m_disableWavesOffset;

	float   m_waterPropertiesOffsetMinimum;
	float   m_waterPropertiesOffsetScale;
	float   m_waterPropertiesDisplacementOffsetScale;
	float   m_waveSkew;
	float   m_lerpOutEndMultiplier;
	
    int     m_debug;
    float   m_debug0;
    float   m_debug1;
    float   m_debug2;


    int     m_frame0; //32 bit
    int     m_frame1;
};

// Same as quadtree-mgr.h QtDeformation
struct DeformationObject
{
	float   m_extent; // ex
	float   m_width;  // size of deformation object
	float   m_length;
	float   m_depth; 

	float   m_startLength;  // size of deformation object
	float   m_endLength; 
	float   m_uOffset; 
	float   m_uScale; 

	float   m_vOffset; 
	float   m_vScale; 
	float   m_blend; // Blend from (0 = cull water, to 1 = covered with water)
	float   m_uvSlot;

	float   m_attachmentOffsetBack;
	float   m_attachmentOffsetFront;
	uint    m_invert; // push water down (0), or push water up (1)
	float   m_pad3;

	int     m_useSecondary;
	float   m_heightBack;
	float   m_heightFront;
	float   m_pad30;

	float   m_radiusFrontFactor;
	float   m_radiusBackFactor;
	float   m_radiusFront;
	float   m_radiusBack;

	float   m_startLengthForPlane;
	float   m_endLengthForPlane;
	float   m_pad12;
	float   m_pad13;

	float   m_misc0;
	float   m_misc1;
	float   m_misc2;
	float   m_msic3;

	float   m_misc4;
	float   m_misc5;
	float   m_misc6;
	float   m_misc7;

	
	float4  m_pos0; 
	float4  m_pos1;
	float4  m_up;   // up vector
};

// Same as quadtree-mgr.h QtDeformation
struct QTDeformation
{
	int     m_numObjects;
	float   m_numUvSlots;
	int     m_pad02;
	int     m_pad03;

	DeformationObject m_object[16];
};


int MT(int i, int j, int W)
{
    return i + j*W;
}

// structure than encodes everything needed to
// evaluate a wave
struct WaveData 
{
	float2 m_xz; // base position
	float4 m_x4; // repeated
	float4 m_z4;

	float4 m_x42; // repeated
	float4 m_z42;

	float3 m_center;
	float3 m_offsetPos;
	float  m_offset;
	float4 m_freqMask;
	float4 m_freqOffset;
	float  m_sizefside;
	float  m_distance;
	float  m_lerpValue;
	float4 m_gridScaleX1;
	float4 m_gridScaleZ1;
	float4 m_gridScaleX2; 
	float4 m_gridScaleZ2;
	float4 m_scaleNormal;
	float4 m_lerpInStartDistance;
	float4 m_lerpInEndDistance;
	float4 m_lerpOutDistance;
	float4 m_foamStart;
	float4 m_foamEnd;
	float4 m_subsurfaceStart;
	float4 m_subsurfaceEnd;
	float4 m_strain;

	float  m_foamBias;
	float  m_foamOffset;
	float  m_subsurfaceBias;
	float  m_subsurfaceOffset;
	float  m_strainBias;

	float  m_fgridSide;
	int    m_gridSide;

	StructuredBuffer<uint4>  m_dataGrid0;
	StructuredBuffer<uint4>  m_dataGrid1;
	StructuredBuffer<uint4>  m_dataGrid2;
	StructuredBuffer<uint4>  m_dataGrid3;
};

// Output structure containing all computed aspects from waves
struct WaveDisplacement 
{
	float3 m_position;
	float3 m_displacement;			// OK
	float3 m_normal;				// OK
	float2 m_flow;
	float3 m_velocity;
	float  m_foam;					// OK
	float  m_subsurface;			// OK
	float  m_height;
	float  m_amplitude;
	float2 m_textureUV;
	float2 m_blend;					// x,y = flow blend
	float  m_strain;				// OK
	float4 m_lerpDistance;			// OK, value for lerp out offset/normal by distance
	float3 m_heightNormal;
	float  m_lerp;					// OK
	float  m_alpha;
	float4 m_debug;					// OK, but debug only??
	uint   m_status; // if necessary to mark we are inside out  
};

struct Flow 
{
	float4 m_xflow1;
	float4 m_zflow1;
	float4 m_xflow2;
	float4 m_zflow2;
	float2 m_flowOrig;
	float  m_blendLimit;
	float  m_amplitude;
	float  m_fblendVal1;
	float  m_fblendVal2;
};

struct TextureData
{
	float4 m_freqMask;

	float3 m_flow;
	float  m_height;
	float3 m_heightNormal;
	float  m_alpha;
};

// This has to be exactly the same as the water.fx
// We might want to change it at some point
// Too much crud 
struct VertexShaderOutput
{
	float4 hPosition			: SV_POSITION;  //Required output
	float3 worldPosition		: TEXCOORD0;
	float2 uv0					: TEXCOORD1;
	float2 uv1					: TEXCOORD2;
	float3 worldNormal			: TEXCOORD3;
	float4 worldTangent			: TEXCOORD4;
	float3 worldBinormal		: TEXCOORD5;
	float  waveFoamMask			: TEXCOORD6;
	float  waveSubsurfaceMask	: TEXCOORD7;
	float3 lastFramePositionHS	: TEXCOORD8;
	float4 color0				: TEXCOORD9;	// Debug	
};

struct QuadTreeSrtData
{
	QuadBlockConstantInfo              * m_consts;
	QuadBlockConstantInfo              * m_constsPrev;
	QuadBlockInstance                  * m_blocks;
	QTDeformation                      * m_deformation;
	RWStructuredBuffer<uint>             m_compactList;
	RWStructuredBuffer<QuadTreeVertex>   m_output;
	TexturesAndSamplers                * m_texturesAndSamplers;
	uint                                 m_gdsNumBoxesCounter;
};

struct SrtData
{
	QuadTreeSrtData * m_data;
};

float nfmod(float a,float b)
{
    return a - b * floor(a / b);
}

float2 nfmod(float2 a,float2 b)
{
    return a - b * floor(a / b);
}

float3 normalBlendUnity(float3 normalBase, float3 normalDetail)
{
	// base and detail are -1 - 1
	float3x3 basis;
	basis[0] = float3(normalBase.z, normalBase.y, -normalBase.x);
	basis[1] = float3(normalBase.x, normalBase.z, -normalBase.y);
	basis[2] = float3(normalBase.x, normalBase.y, normalBase.z);

	return normalize(normalDetail.x*basis[0] + normalDetail.y*basis[1] + normalDetail.z*basis[2]);

}

struct SrtVsData
{
	QuadBlockConstantInfo             * m_consts;
	StructuredBuffer<QuadTreeVertex>    m_grid;
};

void LoadGrid(out GridStructure grids, TexturesAndSamplers *textures, float4 octave=1.0)
{
	grids.m_dataGrid0 = textures->m_wpDataGrid0;
	grids.m_dataGrid1 = textures->m_wpDataGrid1;
	grids.m_dataGrid2 = textures->m_wpDataGrid2;
	grids.m_dataGrid3 = textures->m_wpDataGrid3;

	grids.m_octave = octave;
}

void LoadGridPrev(out GridStructure grids, TexturesAndSamplers *textures, float4 octave=1.0)
{
	grids.m_dataGrid0 = textures->m_wpDataGridPrev0;
	grids.m_dataGrid1 = textures->m_wpDataGridPrev1;
	grids.m_dataGrid2 = textures->m_wpDataGridPrev2;
	grids.m_dataGrid3 = textures->m_wpDataGridPrev3;

	grids.m_octave = octave;
}

void GetWaveData(TextureData txData,
		 float x, float z,
		 QuadBlockConstantInfo *consts, 
		 GridStructure grids,
		 bool useForRendering,
		 out WaveData waveData)
{
	float3 center = consts->m_center.xyz;

	center = (useForRendering) ? center : float3(x,0,z);
	waveData.m_center = center;
	waveData.m_offset = consts->m_offset;
	waveData.m_freqMask   = txData.m_freqMask;
	waveData.m_freqOffset = consts->m_wpFrequencyOffset;

	waveData.m_distance = length(center - waveData.m_offsetPos);
	waveData.m_scaleNormal = consts->m_wpDispNormal;

	waveData.m_gridSide		    = consts->m_wpSide;  
	waveData.m_fgridSide	    = consts->m_wpSide;
	waveData.m_lerpOutDistance  = consts->m_wpLerpOutDistance;
	waveData.m_foamStart	    = consts->m_wpFoamStart;
	waveData.m_foamEnd          = consts->m_wpFoamEnd;
	waveData.m_subsurfaceStart  = consts->m_wpSubsurfaceStart;
	waveData.m_subsurfaceEnd    = consts->m_wpSubsurfaceEnd;
	waveData.m_foamBias         = consts->m_foamBias;
	waveData.m_foamOffset       = consts->m_foamOffset;
	waveData.m_subsurfaceBias   = consts->m_subsurfaceBias;
	waveData.m_subsurfaceOffset = consts->m_subsurfaceOffset;
	waveData.m_strain           = consts->m_wpStrain;
	waveData.m_strainBias       = consts->m_strainBias;

	waveData.m_dataGrid0 = grids.m_dataGrid0;
	waveData.m_dataGrid1 = grids.m_dataGrid1;
	waveData.m_dataGrid2 = grids.m_dataGrid2;
	waveData.m_dataGrid3 = grids.m_dataGrid3;
}

Flow InitFlow(QuadBlockConstantInfo *consts, TextureData txData)
{
	Flow flow;

	flow.m_xflow1 = 0; 
	flow.m_zflow1 = 0; 
	flow.m_xflow2 = 0; 
	flow.m_zflow2 = 0;
	flow.m_flowOrig = txData.m_flow.xy;
	flow.m_blendLimit = 0;
	flow.m_amplitude = txData.m_flow.z;
	flow.m_fblendVal1 = consts->m_blendValue;      // consts->m_octaveBlend;
	flow.m_fblendVal2 = 1.0f - flow.m_fblendVal1;  // flow blend values
	
	return flow;
}

void GetTextureCoords(float x, float z, 
					  QuadBlockConstantInfo *consts,
					  TexturesAndSamplers   *textures,			 
					  SamplerState	       textureSampler,
					  out float uTx, out float vTx)
{
	bool useTexture = consts->m_useFlags != 0;

	uTx = useTexture ? (x - consts->m_deformationPosScale.x) / (consts->m_deformationPosScale.z) : x;
	vTx = useTexture ? (z - consts->m_deformationPosScale.y) / (consts->m_deformationPosScale.w) : z;


}


void GetTextureData(float2 xz,
					float2 uv,
					int    fetchAlpha,
					QuadBlockConstantInfo *consts,
					TexturesAndSamplers   *textures,
					SamplerState	       textureSampler,
					inout TextureData txData)
{
	// For mesh rendering we don't care about alpha cutout
	// But for the displacement query we do
	txData.m_alpha = 1;
	[branch]
	if (fetchAlpha && consts->m_useFlags & kUseAlphaMask) {
	 	txData.m_alpha = textures->m_alphaMaskTx.SampleLevel(textureSampler, uv, 0).r;
	}
	txData.m_flow = float3(.5,.5,1);
	[branch]
	if (consts->m_useFlags & kUseFlow) {
		txData.m_flow = textures->m_flowTx.SampleLevel(textureSampler, uv, 0).rgb;
	}
	txData.m_height = 0;
	[branch]
	if (consts->m_useFlags & kUseHeightmap) { 
		float2 heightVal =  textures->m_heightfieldTx.SampleLevel(textureSampler, uv, 0).rg; 
		txData.m_height = heightVal.r + (heightVal.g / 255.0);


	}
#ifdef DISABLE_WAVE_DEFORMATION
	txData.m_heightNormal = float3(0,0,1);
#else
	txData.m_heightNormal = float3(0,0,1);
#endif
	[branch]
	if (consts->m_useFlags & kUseHeightmapNormal) { 
		float2 normalMap  = textures->m_heightfieldNormalTx.SampleLevel(textureSampler, uv, 0).rg; 

		// convert tangent normal map to world normal
		float3 vTangentNormal;
		vTangentNormal.xy = (normalMap * 2.0 - 1.0);
		//vTangentNormal.y *= -1;
		vTangentNormal.z  = sqrt (saturate (1.0 - dot (vTangentNormal.xy, vTangentNormal.xy)));
		txData.m_heightNormal.xyz = normalize(vTangentNormal.xyz);
	}
	txData.m_freqMask = float4(1);

	[branch]
	if (consts->m_useFlags & kUseFrequencyMask) {
	 	txData.m_freqMask = textures->m_frequencyMaskTx.SampleLevel(textureSampler, uv, 0);

	}
	[branch]
	if (consts->m_frequencyInLerp > 0) {
		// compute distance
		float d = distance(consts->m_freqCenter.xz, xz);
		float4 scaleD = saturate(linearstep(consts->m_wpLerpInStartDistance, consts->m_wpLerpInEndDistance, d));
		// remap 0..1 ->  freqIn..1
		txData.m_freqMask = lerp(txData.m_freqMask, (1.0 - scaleD) * consts->m_wpFrequencyIn + scaleD, consts->m_frequencyInLerp);
	}
}

float GetAlpha(float uTx, float vTx,
			   QuadBlockConstantInfo *consts, 
			   TexturesAndSamplers   *textures,			 
			   SamplerState	        textureSampler)
{
	float alpha = 1;
    [branch]
	if (consts->m_useFlags & kUseAlphaMask) {
		alpha = textures->m_alphaMaskTx.SampleLevel(textureSampler, float2(uTx,vTx), 0).r;
	}
   return alpha;
}

void GetFlow(float x, float z, float uTx, float vTx,
			 QuadBlockConstantInfo *consts, 
			 TexturesAndSamplers   *textures,			 
			 SamplerState	        textureSampler,
			 inout Flow flow)
{
	float xp = x;
	float zp = z;

	float3 heightmapVal = 0.0f;	
	float  displacementY = 0.0f;

	float  fblendVal1 = 0;
	float  fblendVal2 = 1.0f - fblendVal1;  // flow blend values

	float4 xflow1=0, zflow1=0, xflow2=0, zflow2=0;
	float  blendLimit = 0;
	float  amplitude = 1.0;

	float2 flowTx = flow.m_flowOrig;
	float2 flowDir = flowTx.xy * 2.0 - 1.0;

	// if (consts->m_debug != 0) {
	
	//  float2 flowa;
	//  float cs,ss;
	//  sincos(consts->m_debug0, cs, ss);
	//  flowa.x = cs * flowDir.x - ss * flowDir.y;
	//  flowa.y = ss * flowDir.x + cs * flowDir.y;
	//  flowDir.xy  = flowa.xy;
	// }

	float timeIntervalInSec = consts->m_flowInterval; 
	float timeFlow   = consts->m_time / timeIntervalInSec;

	float2 scrollTime = frac(float2(timeFlow, timeFlow - 0.5f)) * 2.0f - 1.0f;

	float4  scrollTime4x = (scrollTime.x * consts->m_flowMagnitude) * consts->m_flowStrength;
	float4  scrollTime4y = (scrollTime.y * consts->m_flowMagnitude) * consts->m_flowStrength;

	xflow1 = scrollTime4x * flowDir.x;
	zflow1 = scrollTime4x * flowDir.y;

	xflow2 = scrollTime4y * flowDir.x;
	zflow2 = scrollTime4y * flowDir.y;

	fblendVal2 = abs(2.0 * (1.0f - frac(timeFlow - 0.5f)) - 1.0f);
	fblendVal1 = 1.0f - fblendVal2;
  
	bool expr = (uTx >= 0.0f && uTx <= 1.0f && vTx >= 0.0f && vTx <= 1.0f);
	blendLimit = expr ? 1.0f : 0.0f;

	flow.m_blendLimit = blendLimit;

	// out flow params
	flow.m_xflow1		 = xflow1 *		blendLimit;
	flow.m_zflow1		 = zflow1 *		blendLimit;
	flow.m_xflow2		 = xflow2 *		blendLimit;
	flow.m_zflow2		 = zflow2 *		blendLimit;
	flow.m_fblendVal1	 = fblendVal1; // expr ? fblendVal1 : 1.0f;
	flow.m_fblendVal2	 = fblendVal2; // expr ? fblendVal2 : consts->m_octaveBlend;
} 

void GetWaveDataPositionScroll(float x, float z,
							   float4 xoff, float4 zoff,
							   QuadBlockConstantInfo *consts, 
							   float4 octaveScale,
							   float4 scaleX,
							   float4 scaleZ,
							   inout WaveData waveData)
{
	waveData.m_xz = float2(x,z);
	waveData.m_offsetPos = float3(x, consts->m_offset, z);

	waveData.m_gridScaleX1 = scaleX;
	waveData.m_gridScaleZ1 = scaleZ;

	waveData.m_gridScaleX2 = octaveScale * scaleX;  // reuse the blend
	waveData.m_gridScaleZ2 = octaveScale * scaleZ;

	waveData.m_x4 = float4(x) + xoff + consts->m_wpPositionX;  
	waveData.m_z4 = float4(z) + zoff + consts->m_wpPositionZ;  

	waveData.m_x42 = float4(x) + xoff + consts->m_wpPositionX;  
	waveData.m_z42 = float4(z) + zoff + consts->m_wpPositionZ;  
}

void WPCompressDisp(float3 disp, out uint4 comp)
{
	uint3 disp16 = f32tof16(disp);

	uint w2 = disp16.x | disp16.y << 16;
	uint w3 = disp16.z;

	comp = uint4(0, 0, w2, w3);
}

void WPCompressData(WPDisplacement wp, inout uint4 comp)
{
	// remap -4..4 to 0..1
	float3 dx = clamp((wp.m_dx + 4.f) * 0.125f, 0, 1);
	float3 dz = clamp((wp.m_dz + 4.f) * 0.125f, 0, 1);

	uint udx = PackRg11B10(dx);
	uint udz = PackRg11B10(dz);
	uint strain16 = f32tof16(wp.m_strain);

	uint w0 = udx;
	uint w1 = udz;
	uint w2 = comp.z;
	uint w3 = comp.w | strain16 << 16;

	comp = uint4(w0, w1, w2, w3);
}

void WPDecompress(out WPDisplacement wp, uint4 comp)
{
	uint3	disp = float3(comp.z & 0xffff, comp.z >> 16, comp.w & 0xffff);
	float3	dx = UnpackRg11B10(comp.x);
	float3	dz = UnpackRg11B10(comp.y);
	float	strain = f16tof32(comp.w >> 16);

	wp.m_disp = f16tof32(disp);
	wp.m_dx = (dx * 8.f) - 4.f;
	wp.m_dz = (dz * 8.f) - 4.f;
	wp.m_strain = strain;
}

void InterpolateWaveData(float2 t, out WPDisplacement wpdisp, WaveData waveData, StructuredBuffer<uint4> dataGrid)
{
	float tsx = t.x;
	float tsz = t.y;

	float tfx = tsx * waveData.m_fgridSide;
	float tfz = tsz * waveData.m_fgridSide;

	float ixf0 = (tsx - floor(tsx)) * waveData.m_fgridSide;
	float izf0 = (tsz - floor(tsz)) * waveData.m_fgridSide;
	// float4 ixf0 = tsx * waveData.m_fgridSide - floor(tsx) * waveData.m_fgridSide;
	// float4 izf0 = tsz * waveData.m_fgridSide - floor(tsz) * waveData.m_fgridSide;

	int ix0 = int(ixf0);
	int iz0 = int(izf0);

	// Fractional part between elements
	float tx = tfx - floor(tfx);
	float tz = tfz - floor(tfz);

	float txm = 1.0f - tx;
	float tzm = 1.0f - tz;

	// Next index
	int   ix1 = ix0 + 1;
	int   iz1 = iz0 + 1;

	// wrap around
	ix1 = (ix1 >= waveData.m_gridSide)? ix1 - waveData.m_gridSide : ix1;
	iz1 = (iz1 >= waveData.m_gridSide)? iz1 - waveData.m_gridSide : iz1;

	WPDisplacement p00;
	WPDisplacement p10;
	WPDisplacement p01;
	WPDisplacement p11;

	WPDecompress(p00, dataGrid[ MT(ix0, iz0, waveData.m_gridSide) ]);
	WPDecompress(p10, dataGrid[ MT(ix0, iz1, waveData.m_gridSide) ]);
	WPDecompress(p01, dataGrid[ MT(ix1, iz0, waveData.m_gridSide) ]);
	WPDecompress(p11, dataGrid[ MT(ix1, iz1, waveData.m_gridSide) ]);

	float txmzm = txm * tzm;
	float txzm  = tx  * tzm;
	float txmz  = txm * tz;
	float txz   = tx  * tz;

	wpdisp.m_disp.xyz =	txmzm * p00.m_disp.xyz + txzm * p01.m_disp.xyz + txmz * p10.m_disp.xyz + txz * p11.m_disp.xyz;
	wpdisp.m_dx.xyz =	txmzm * p00.m_dx.xyz +	 txzm * p01.m_dx.xyz +   txmz * p10.m_dx.xyz +   txz * p11.m_dx.xyz;
	wpdisp.m_dz.xyz =	txmzm * p00.m_dz.xyz +	 txzm * p01.m_dz.xyz +   txmz * p10.m_dz.xyz +   txz * p11.m_dz.xyz;
	wpdisp.m_strain =	txmzm * p00.m_strain +	 txzm * p01.m_strain +   txmz * p10.m_strain +   txz * p11.m_strain;
}

void GetWaveDisplacement(QuadBlockConstantInfo *consts, WaveData waveData, TextureData txData, float4 x4, float4 z4, float4 gridScaleX, float4 gridScaleZ, out WaveDisplacement waveOut, bool useForRendering)
{
	WPDisplacement wp0;
	WPDisplacement wp1;
	WPDisplacement wp2;
	WPDisplacement wp3;

	{
		float4 tsx = x4 / gridScaleX;
		float4 tsz = z4 / gridScaleZ;

		tsx += tsz*consts->m_waveSkew;

		InterpolateWaveData(float2(tsx.x, tsz.x), wp0, waveData, waveData.m_dataGrid0);
		InterpolateWaveData(float2(tsx.y, tsz.y), wp1, waveData, waveData.m_dataGrid1);
		InterpolateWaveData(float2(tsx.z, tsz.z), wp2, waveData, waveData.m_dataGrid2);
		InterpolateWaveData(float2(tsx.w, tsz.w), wp3, waveData, waveData.m_dataGrid3);                      
	}

	float3 d0 = wp0.m_disp.xyz;
	float3 d1 = wp1.m_disp.xyz;
	float3 d2 = wp2.m_disp.xyz;
	float3 d3 = wp3.m_disp.xyz;

	float3 displacement = d0.zyx + d1.zyx + d2.zyx + d3.zyx;

	float d = distance(waveData.m_center, waveData.m_offsetPos + displacement);
	float4 scaleD = saturate(linearstep(consts->m_lerpOutEndMultiplier * waveData.m_lerpOutDistance, waveData.m_lerpOutDistance, d));

	// when useForRendering - lerp frequencies by distance to camera
	// NO lerping when doing queries
	scaleD = (useForRendering) ? scaleD : 1.0;
	
	// mask off frequencies
	d0 = lerp(float3(0,waveData.m_freqOffset.x,0), scaleD.x * d0.zyx, waveData.m_freqMask.x);
	d1 = lerp(float3(0,waveData.m_freqOffset.y,0), scaleD.y * d1.zyx, waveData.m_freqMask.y);
	d2 = lerp(float3(0,waveData.m_freqOffset.z,0), scaleD.z * d2.zyx, waveData.m_freqMask.z);
	d3 = lerp(float3(0,waveData.m_freqOffset.w,0), scaleD.w * d3.zyx, waveData.m_freqMask.w);

	// use frequency mask to control normal/foam/subsurface
	scaleD *= waveData.m_freqMask;
	scaleD = max(.0001, scaleD);
	
	waveOut.m_displacement  = d0 + d1 + d2 + d3; 

	float3 axisX = float3(1,0,0);
	float3 axisZ = float3(0,0,1);

	float3 nDx0 = wp0.m_dx.xyz;
	float3 nDx1 = wp1.m_dx.xyz;
	float3 nDx2 = wp2.m_dx.xyz;
	float3 nDx3 = wp3.m_dx.xyz;

	float3 nDz0 = wp0.m_dz.xyz;
	float3 nDz1 = wp1.m_dz.xyz;
	float3 nDz2 = wp2.m_dz.xyz;
	float3 nDz3 = wp3.m_dz.xyz;

#if 0 //Shitty old cheap normals
	nDx0 *= scaleD.x ;
	nDx1 *= scaleD.y ;
	nDx2 *= scaleD.z ;
	nDx3 *= scaleD.w ;
	nDz0 *= scaleD.x ;
	nDz1 *= scaleD.y ;
	nDz2 *= scaleD.z ;
	nDz3 *= scaleD.w ;

	waveOut.m_normal = cross(nDz0 + nDz1 + nDz2 + nDz3, nDx0 + nDx1 + nDx2 + nDx3) * float3(1,.25,1);
	waveOut.m_normal = normalize(max(-1, waveOut.m_normal.xyz));

#else // More expensive normals that blend out properly with lerpOut and frequency mask
	float3 n0 = cross(nDx0, nDz0);
	float3 n1 = cross(nDx1, nDz1);
	float3 n2 = cross(nDx2, nDz2);
	float3 n3 = cross(nDx3, nDz3);

	n0 *= (n0.y < 0)? -1 : 1;
	n1 *= (n1.y < 0)? -1 : 1;
	n2 *= (n2.y < 0)? -1 : 1;
	n3 *= (n3.y < 0)? -1 : 1;

	n0 = lerp(float3(0,1,0), normalize(n0) , scaleD.x);
	n1 = lerp(float3(0,1,0), normalize(n1) , scaleD.y);
	n2 = lerp(float3(0,1,0), normalize(n2) , scaleD.z);
	n3 = lerp(float3(0,1,0), normalize(n3) , scaleD.w);

	waveOut.m_normal = normalize((n0+n1+n2+n3) * float3(1,.1,1)); 
#endif

	waveOut.m_foam = waveData.m_foamBias * dot(saturate(scaleD), saturate(linearparam(waveData.m_foamStart, waveData.m_foamEnd, float4(d0.y, d1.y, d2.y, d3.y)))) + waveData.m_foamOffset;

	waveOut.m_subsurface = waveData.m_subsurfaceBias * dot(saturate(scaleD), saturate(linearparam(waveData.m_subsurfaceStart, waveData.m_subsurfaceEnd, float4(d0.y, d1.y, d2.y, d3.y)))) + waveData.m_subsurfaceOffset;

	float4 strain;

	strain.x = wp0.m_strain;
	strain.y = wp1.m_strain;
	strain.z = wp2.m_strain;
	strain.w = wp3.m_strain;

	float strainVal = waveData.m_strainBias * max(0, strain.x * strain.y * strain.z * strain.w);
	waveOut.m_strain = saturate(strainVal);

	waveOut.m_lerpDistance = scaleD;
	waveOut.m_lerp  = saturate(dot(1, scaleD));
	waveOut.m_debug = scaleD;
}

void BlendValues(QuadBlockConstantInfo *consts, inout WaveDisplacement waveOut1, inout WaveDisplacement waveOut2)
{ 
	waveOut1.m_displacement = lerp(waveOut1.m_displacement, waveOut2.m_displacement, consts->m_octaveBlend);
	waveOut1.m_normal       = lerp(waveOut1.m_normal,       waveOut2.m_normal,       consts->m_octaveBlend);
	waveOut1.m_foam         = lerp(waveOut1.m_foam,         waveOut2.m_foam,         consts->m_octaveBlend);
	waveOut1.m_subsurface   = lerp(waveOut1.m_subsurface,   waveOut2.m_subsurface,   consts->m_octaveBlend);

	waveOut1.m_strain   = lerp(waveOut1.m_strain,   waveOut2.m_strain,   consts->m_octaveBlend);
}

void GetDisplacement(float x, float z, 
					 float uTx, float vTx,
					 TextureData txData,
					 QuadBlockConstantInfo *consts, 
					 TexturesAndSamplers   *textures,
					 SamplerState	        textureSampler,
					 GridStructure          grids,
					 float2                 flowBlendSelect,
					 bool                   useForRendering,
					 out WaveDisplacement waveOut)
{
	float xp = x;
	float zp = z;

	[branch]
	if (consts->m_useFlags & kUseUVDistortionTexture) {
		float2 distort = textures->m_uvDistortionTx.SampleLevel(textureSampler, float2(uTx, vTx), 0).rg * 2.0 - 1.0;
		distort *= consts->m_uvDistortionScale; //;

		x += distort.x;
		z += distort.y;
	}
	 	
	Flow flow;

	flow = InitFlow(consts, txData);

	float4 scaleX1, scaleZ1;
	float4 scaleX2, scaleZ2;

	// Blending normally between two sets
	scaleX1 = consts->m_wpScaleX;
	scaleZ1 = consts->m_wpScaleZ;
	scaleX2 = consts->m_wpScaleXBlend;
	scaleZ2 = consts->m_wpScaleZBlend;

	[branch]
	if (consts->m_useFlags & kUseFlow) {
		GetFlow(x, z, uTx, vTx, consts, textures, textureSampler, flow);

		// For flow, we use the same parameter
		scaleX2 = consts->m_wpScaleX;
		scaleZ2 = consts->m_wpScaleZ;
	}

	groupshared WaveDisplacement waveOut2 ,waveOut3;	
	waveOut.m_flow  = 0;
	waveOut2.m_flow = 0;
	waveOut3.m_flow = 0;

	// Evaluate waves
	WaveData waveData; 

	{
		GetWaveData(txData, x,z, consts, grids, useForRendering, waveData);

		// First grid (sample two grid with an octave shift)
		GetWaveDataPositionScroll(x, z, flow.m_xflow1, flow.m_zflow1, consts, grids.m_octave, scaleX1, scaleZ1, waveData);
		GetWaveDisplacement(consts, waveData, txData, waveData.m_x4, waveData.m_z4,   waveData.m_gridScaleX1, waveData.m_gridScaleZ1, waveOut, useForRendering);
		GetWaveDisplacement(consts, waveData, txData, waveData.m_x42, waveData.m_z42, waveData.m_gridScaleX2, waveData.m_gridScaleZ2, waveOut2, useForRendering);
		BlendValues(consts, waveOut, waveOut2); // blending the octaves

		// First grid (sample two grid with an octave shift) (reuse waveOut2)
		GetWaveDataPositionScroll(x, z, flow.m_xflow2, flow.m_zflow2, consts, grids.m_octave, scaleX2, scaleZ2, waveData);
		GetWaveDisplacement(consts, waveData, txData, waveData.m_x4,  waveData.m_z4,  waveData.m_gridScaleX1, waveData.m_gridScaleZ1, waveOut2, useForRendering);
		GetWaveDisplacement(consts, waveData, txData, waveData.m_x42, waveData.m_z42, waveData.m_gridScaleX2, waveData.m_gridScaleZ2, waveOut3, useForRendering);
		BlendValues(consts, waveOut2, waveOut3);
	}


	float3 displacement;
	{
		// Blend heightmap normal

		// displacement         = consts->m_multY * flow.m_amplitude * 
		// 	                  (flowBlendSelect.x * waveOut.m_displacement + flowBlendSelect.y * waveOut2.m_displacement);

#ifdef DISABLE_WAVE_DEFORMATION
		waveOut.m_normal     = float3(0,1,0);
		waveOut.m_foam       = 0;
		waveOut.m_subsurface = 0;
		waveOut.m_strain     = 0;
		waveOut.m_flow       = 0.5f;
		waveOut.m_blend      = 0;
		waveOut.m_velocity   = 0;
		displacement 		 = 0;
#else
		displacement         = consts->m_multY * (flowBlendSelect.x * waveOut.m_displacement + flowBlendSelect.y * waveOut2.m_displacement);
		displacement.xz     *= flow.m_amplitude;
		displacement.y       = lerp(consts->m_amplitudeOffset, displacement.y, flow.m_amplitude);

		waveOut.m_normal     = flowBlendSelect.x * waveOut.m_normal       + flowBlendSelect.y * waveOut2.m_normal;
		waveOut.m_foam       = flowBlendSelect.x * waveOut.m_foam         + flowBlendSelect.y * waveOut2.m_foam;
		waveOut.m_subsurface = flowBlendSelect.x * waveOut.m_subsurface   + flowBlendSelect.y * waveOut2.m_subsurface;
		waveOut.m_strain     = flowBlendSelect.x * waveOut.m_strain       + flowBlendSelect.y * waveOut2.m_strain;  

		waveOut.m_flow       = flow.m_flowOrig;
		waveOut.m_blend      = flow.m_fblendVal1;
#endif
		waveOut.m_textureUV = float2(uTx, vTx);

		displacement.y += consts->m_terrainMag * txData.m_height;
	}

	waveOut.m_status = kOk;

#if !defined DISABLE_WAVE_DEFORMATION
	if (! all(isfinite(displacement))) {
		waveOut.m_status = kNotFinite;
	}
#endif

	waveOut.m_displacement = displacement;
	waveOut.m_position     = float3(xp, consts->m_offset, zp) + displacement;
	{
		float3 n1 = txData.m_heightNormal;
		n1.y *= -1;

		float3 n2 = waveOut.m_normal;

		waveOut.m_normal = normalBlendUnity(n1, n2);

	}
#ifdef DISABLE_WAVE_DEFORMATION
	waveOut.m_velocity     = 0;
	waveOut.m_debug.xyz    = txData.m_heightNormal;
	waveOut.m_amplitude    = 0;
#else
	waveOut.m_velocity     = displacement - float3(dot(consts->m_wpScrollX, 1.0f), 0.0f, dot(consts->m_wpScrollZ, 1.0f));
	waveOut.m_debug.xyz    = (1.0-waveOut.m_lerp) * txData.m_heightNormal + waveOut.m_lerp * waveOut.m_normal;
	waveOut.m_amplitude    = flow.m_amplitude;
#endif
	waveOut.m_heightNormal = txData.m_heightNormal;
	waveOut.m_alpha        = txData.m_alpha;
}

