#ifndef __TILE_UTIL_FXI__
#define __TILE_UTIL_FXI__

float2 GetHTileMinMax(uint htile)
{
	const uint kMaximumZValue = (1<<14) - 1;

	float minZ = ((htile >> 4) & kMaximumZValue) / float(kMaximumZValue);
	float maxZ = ((htile >> 18) & kMaximumZValue) / float(kMaximumZValue);
	
	return float2(minZ, maxZ);
}

uint getPipeIndexOfTile(uint x, uint y, uint num_pipes)
{
	uint pipe = 0;
	pipe |= (((x >> 0) ^ (y >> 0) ^ (x >> 1)) & 0x1) << 0;
	pipe |= (((x >> 1) ^ (y >> 1)) & 0x1) << 1;
	pipe |= (((x >> 2) ^ (y >> 2)) & 0x1) << 2;
	if (num_pipes == 16)
		pipe |= (((x >> 3) ^ (y >> 2)) & 0x1) << 3;
	return pipe;
}

void computeCmaskBufferNybbleOffset(out uint outOffset, out uint outNybble, uint tileX, uint tileY, uint tilesWide, bool isLinear, bool isNeo)
{
	const uint pipe_interleave = 256;
	const uint cl_size = 256; // 256 BYTES per PIPE in a CACHELINE
	const uint num_pipes = isNeo ? 16 : 8;
	const uint macro_shift = (16 - num_pipes) >> 3;
	const uint cl_width = 64;
	const uint cl_height = num_pipes << 2;
	const uint cl_x = tileX / cl_width;
	const uint cl_y = tileY / cl_height;
	const uint surf_pitch_cl = (tilesWide + cl_width - 1) / cl_width;
	const uint cl_offset = isLinear ? 0 : ((cl_x + surf_pitch_cl * cl_y) * cl_size);

	const uint macro_x = (isLinear ? tileX : (tileX % cl_width)) / 4;
	const uint macro_y = (isLinear ? tileY : (tileY % cl_height)) / 4;
	const uint macro_pitch = (isLinear ? tilesWide : cl_width) / 4;
	uint macro_offset = (macro_x + macro_y * macro_pitch) << macro_shift;

	macro_offset &= ~3;
	macro_offset |= (((tileX >> 1) ^ (tileY >> 0)) & 1) << 0;
	macro_offset |= (((tileX >> 1)) & 1) << 1;

	const uint tile_number = cl_offset + macro_offset;
	const uint device_address = tile_number >> 1;
	const uint pipe = getPipeIndexOfTile(tileX, tileY, num_pipes);
	const uint final_address = (device_address % pipe_interleave) + (pipe * pipe_interleave) + (device_address / pipe_interleave) * pipe_interleave * num_pipes;

	outOffset = final_address;
	outNybble = tile_number & 1;
}

uint HTileOffsetInDwords(uint tileX, uint tileY, uint tilesWide, bool isLinear, bool isNeo)
{
	const uint pipe_interleave = 256;
	const uint cl_size = 512; // 512 DWORDS per PIPE in a CACHELINE
	const uint num_pipes = isNeo ? 16 : 8;
	const uint macro_shift = (16 - num_pipes) >> 3;
	const uint cl_width = num_pipes << 3;
	const uint cl_height = 64;
	const uint cl_x = tileX / cl_width;
	const uint cl_y = tileY / cl_height;
	const uint surf_pitch_cl = (tilesWide + cl_width - 1) / cl_width;
	const uint cl_offset = isLinear ? 0 : ((cl_x + surf_pitch_cl * cl_y) * cl_size);

	const uint macro_x = (isLinear ? tileX : (tileX % cl_width)) / 4;
	const uint macro_y = (isLinear ? tileY : (tileY % cl_height)) / 4;
	const uint macro_pitch = (isLinear ? tilesWide : cl_width) / 4;
	uint macro_offset = (macro_y * macro_pitch + macro_x) << macro_shift;

	macro_offset &= ~3;
	macro_offset |= (((tileX >> 1) ^ (tileY >> 0)) & 1) << 0;
	macro_offset |= (((tileX >> 1)) & 1) << 1;

	const uint tile_number = cl_offset + macro_offset;
	const uint device_address = tile_number << 2;
	const uint pipe = getPipeIndexOfTile(tileX, tileY, num_pipes);
	const uint final_address = (device_address % pipe_interleave) + (pipe * pipe_interleave) + (device_address / pipe_interleave) * pipe_interleave * num_pipes;

	return final_address / 4;
 }
#endif
